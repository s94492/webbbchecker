const express = require('express');
const router = express.Router();
const PDFDocument = require('pdfkit');
const fs = require('fs');
const path = require('path');
const moment = require('moment');
const WebsiteService = require('../services/WebsiteStorage');
const axios = require('axios');

const websiteService = new WebsiteService();

// ç”Ÿæˆå–®å€‹ç¶²ç«™çš„ PDF å ±è¡¨
router.get('/:websiteId/pdf', async (req, res) => {
  try {
    const { websiteId } = req.params;
    const { range = '24h' } = req.query;

    console.log(`ç”Ÿæˆç¶²ç«™ ${websiteId} çš„ PDF å ±è¡¨ï¼Œæ™‚é–“ç¯„åœ: ${range}`);

    // ç²å–ç¶²ç«™è³‡è¨Š
    const website = await websiteService.getById(websiteId);
    if (!website) {
      return res.status(404).json({
        error: 'æ‰¾ä¸åˆ°æŒ‡å®šç¶²ç«™'
      });
    }

    // ç²å–ç¶²ç«™çµ±è¨ˆæ•¸æ“š
    let stats = null;
    let metrics = [];
    try {
      const statsResponse = await axios.get(`http://localhost:3001/api/metrics/${websiteId}/stats?range=${range}`);
      stats = statsResponse.data.data;
      
      const metricsResponse = await axios.get(`http://localhost:3001/api/metrics/${websiteId}?range=${range}`);
      metrics = metricsResponse.data.data || [];
    } catch (error) {
      console.log('ç²å–çµ±è¨ˆæ•¸æ“šå¤±æ•—ï¼Œä½¿ç”¨é è¨­å€¼:', error.message);
    }

    // ä½¿ç”¨2é ç²¾è¯ç‰ˆPDFç”Ÿæˆ
    console.log('ä½¿ç”¨2é ç²¾è¯ç‰ˆPDFç”Ÿæˆæ¨¡å¼');
    const pdfBuffer = await generateWebsitePDF(website, stats, metrics, range);

    // è¨­å®šæª”æ¡ˆåç¨±
    const timestamp = moment().format('YYYYMMDD_HHmmss');
    const filename = `${website.name}_report_${range}_${timestamp}.pdf`;

    // è¨­å®šå›æ‡‰æ¨™é ­
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="${encodeURIComponent(filename)}"`);
    res.setHeader('Content-Length', pdfBuffer.length);

    // ç™¼é€PDF
    res.send(pdfBuffer);

    console.log(`PDFå ±è¡¨ç”ŸæˆæˆåŠŸ: ${filename}`);

  } catch (error) {
    console.error('PDFå ±è¡¨ç”Ÿæˆå¤±æ•—:', error);
    res.status(500).json({
      error: 'PDFå ±è¡¨ç”Ÿæˆå¤±æ•—',
      message: error.message
    });
  }
});

// ç”Ÿæˆå–®å€‹ç¶²ç«™çš„ CSV å ±è¡¨
router.get('/:websiteId/csv', async (req, res) => {
  try {
    const { websiteId } = req.params;
    const { range = '24h' } = req.query;

    console.log(`ç”Ÿæˆç¶²ç«™ ${websiteId} çš„ CSV å ±è¡¨ï¼Œæ™‚é–“ç¯„åœ: ${range}`);

    // ç²å–ç¶²ç«™è³‡è¨Š
    const website = await websiteService.getById(websiteId);
    if (!website) {
      return res.status(404).json({
        error: 'æ‰¾ä¸åˆ°æŒ‡å®šç¶²ç«™'
      });
    }

    // ç²å–ç›£æ§æ•¸æ“š
    let metrics = [];
    try {
      const metricsResponse = await axios.get(`http://localhost:3001/api/metrics/${websiteId}?range=${range}`);
      metrics = metricsResponse.data.data || [];
    } catch (error) {
      console.log('ç²å–ç›£æ§æ•¸æ“šå¤±æ•—:', error.message);
    }

    // ç”ŸæˆCSVå…§å®¹
    const csvContent = generateWebsiteCSV(website, metrics, range);

    // è¨­å®šæª”æ¡ˆåç¨±
    const timestamp = moment().format('YYYYMMDD_HHmmss');
    const filename = `${website.name}_data_${range}_${timestamp}.csv`;

    // è¨­å®šå›æ‡‰æ¨™é ­
    res.setHeader('Content-Type', 'text/csv; charset=utf-8');
    res.setHeader('Content-Disposition', `attachment; filename="${encodeURIComponent(filename)}"`);

    // æ·»åŠ  UTF-8 BOM è®“ Excel æ­£ç¢ºè­˜åˆ¥ä¸­æ–‡
    res.write('\uFEFF');
    res.end(csvContent);

    console.log(`CSVå ±è¡¨ç”ŸæˆæˆåŠŸ: ${filename}`);

  } catch (error) {
    console.error('CSVå ±è¡¨ç”Ÿæˆå¤±æ•—:', error);
    res.status(500).json({
      error: 'CSVå ±è¡¨ç”Ÿæˆå¤±æ•—',
      message: error.message
    });
  }
});

// é è¦½å ±è¡¨æ•¸æ“š
router.get('/:websiteId/preview', async (req, res) => {
  try {
    const { websiteId } = req.params;
    const { range = '24h' } = req.query;

    // ç²å–ç¶²ç«™è³‡è¨Š
    const website = await websiteService.getById(websiteId);
    if (!website) {
      return res.status(404).json({
        error: 'æ‰¾ä¸åˆ°æŒ‡å®šç¶²ç«™'
      });
    }

    // ç²å–çµ±è¨ˆæ•¸æ“š
    let stats = null;
    try {
      const statsResponse = await axios.get(`http://localhost:3001/api/metrics/${websiteId}/stats?range=${range}`);
      stats = statsResponse.data.data;
    } catch (error) {
      console.log('ç²å–çµ±è¨ˆæ•¸æ“šå¤±æ•—:', error.message);
    }

    res.json({
      success: true,
      data: {
        website: {
          id: website.id,
          name: website.name,
          url: website.url,
          status: website.status
        },
        stats,
        timeRange: range
      }
    });

  } catch (error) {
    console.error('ç”Ÿæˆå ±è¡¨é è¦½å¤±æ•—:', error);
    res.status(500).json({
      error: 'ç”Ÿæˆå ±è¡¨é è¦½å¤±æ•—',
      message: error.message
    });
  }
});

// PDFç”Ÿæˆå‡½æ•¸ - 2é ç²¾è¯ç‰ˆ
async function generateWebsitePDF(website, stats, metrics, timeRange) {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({ 
        margin: 50,
        lineGap: 2,
        wordSpacing: 1,
        characterSpacing: 0.5,
        info: {
          Title: `${website.name} ç›£æ§å ±è¡¨`,
          Author: 'Website Monitor System',
          Subject: 'ç¶²ç«™ç›£æ§æ•¸æ“šå ±è¡¨',
          Keywords: 'ç›£æ§, æ€§èƒ½, å¯ç”¨æ€§, å ±è¡¨'
        }
      });
      const chunks = [];
      
      doc.on('data', (chunk) => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      
      // è¨»å†Šä¸­æ–‡å­—é«”
      const fontPath = '/app/fonts/NotoSansTC.ttf';
      if (fs.existsSync(fontPath)) {
        console.log('ä½¿ç”¨ Noto Sans TC ä¸­æ–‡å­—é«”');
        doc.registerFont('NotoSansTC', fontPath);
        doc.font('NotoSansTC');
      } else {
        console.log('æ‰¾ä¸åˆ°ä¸­æ–‡å­—é«”æª”æ¡ˆï¼Œä½¿ç”¨é è¨­å­—é«”');
      }
      
      const timeRangeText = getTimeRangeText(timeRange);
      const currentTime = moment().utc().utcOffset(8).format('YYYY-MM-DD HH:mm:ss');
      
      // ========== ç¬¬1é ï¼šåŸ·è¡Œæ‘˜è¦ ==========
      
      // é é¦–è¨­è¨ˆ - æ›´å°ˆæ¥­çš„æ¨£å¼
      doc.rect(0, 0, doc.page.width, 3).fill('#1976D2');
      
      // å…¬å¸/ç³»çµ±æ¨™è­˜ï¼ˆå·¦ä¸Šè§’ï¼‰
      doc.fontSize(10).fillColor('#666')
         .text('ç¶²ç«™ç›£æ§ç³»çµ±', 50, 30)
         .fontSize(8).fillColor('#999')
         .text('è‡ªå‹•ç”Ÿæˆå ±è¡¨', 50, 45);
      
      // å ±è¡¨é¡å‹ï¼ˆå³ä¸Šè§’ï¼‰
      doc.fontSize(10).fillColor('#666')
         .text('æ€§èƒ½ç›£æ§å ±è¡¨', 450, 30, { width: 100, align: 'right' })
         .fontSize(8).fillColor('#999')
         .text(timeRangeText, 450, 45, { width: 100, align: 'right' });
      
      // ä¸»æ¨™é¡Œ
      doc.fontSize(28).fillColor('#1976D2')
         .font('NotoSansTC')
         .text(website.name, 50, 80, { align: 'center', width: 500 });
      
      doc.fontSize(12).fillColor('#666')
         .text(website.url, 50, 115, { align: 'center', width: 500 });
      
      // åˆ†éš”ç·š
      doc.moveTo(50, 140)
         .lineTo(550, 140)
         .strokeColor('#E0E0E0')
         .lineWidth(0.5)
         .stroke();
      
      // åŸ·è¡Œæ‘˜è¦å€å¡Š
      doc.fontSize(16).fillColor('#333')
         .font('NotoSansTC')
         .text('åŸ·è¡Œæ‘˜è¦', 50, 160);
      
      // ç‹€æ…‹ç¸½çµï¼ˆå¤§å¡ç‰‡ï¼‰
      const summaryBoxY = 190;
      const statusColor = stats.uptime >= 99.9 ? '#4CAF50' : 
                         stats.uptime >= 99 ? '#FF9800' : '#F44336';
      const statusText = stats.uptime >= 99.9 ? 'ç³»çµ±é‹è¡Œå„ªç§€' : 
                        stats.uptime >= 99 ? 'ç³»çµ±é‹è¡Œç©©å®š' : 'ç³»çµ±éœ€è¦é—œæ³¨';
      const statusIcon = stats.uptime >= 99.9 ? 'âœ…' : 
                        stats.uptime >= 99 ? 'âš ï¸' : 'âŒ';
      
      // ç‹€æ…‹èƒŒæ™¯æ¡†
      doc.roundedRect(50, summaryBoxY, 500, 60, 5)
         .fillAndStroke('#FAFAFA', statusColor);
      
      doc.fontSize(24).fillColor(statusColor)
         .text(`${statusIcon} ${statusText}`, 70, summaryBoxY + 20, { width: 460 });
      
      doc.fontSize(11).fillColor('#666')
         .text(`åŸºæ–¼éå»${timeRangeText}çš„ç›£æ§æ•¸æ“šåˆ†æ`, 70, summaryBoxY + 45, { width: 460 });
      
      // é—œéµç¸¾æ•ˆæŒ‡æ¨™ï¼ˆ3å€‹å¤§å¡ç‰‡ï¼‰
      doc.fontSize(16).fillColor('#333')
         .font('NotoSansTC')
         .text('é—œéµç¸¾æ•ˆæŒ‡æ¨™', 50, 270);
      
      if (stats) {
        const kpiY = 300;
        const kpiCards = [
          {
            title: 'ç³»çµ±å¯ç”¨æ€§',
            value: `${stats.uptime}%`,
            subtitle: stats.uptime >= 99.9 ? 'SLAé”æ¨™' : stats.uptime >= 99 ? 'æ¥è¿‘ç›®æ¨™' : 'ä½æ–¼æ¨™æº–',
            color: stats.uptime >= 99.9 ? '#4CAF50' : stats.uptime >= 99 ? '#FF9800' : '#F44336',
            icon: 'ğŸ“Š'
          },
          {
            title: 'å¹³å‡å›æ‡‰æ™‚é–“',
            value: formatResponseTime(stats.avgResponseTime),
            subtitle: stats.avgResponseTime < 500 ? 'æ€§èƒ½å„ªç§€' : stats.avgResponseTime < 1000 ? 'æ€§èƒ½è‰¯å¥½' : 'éœ€è¦å„ªåŒ–',
            color: stats.avgResponseTime < 500 ? '#4CAF50' : stats.avgResponseTime < 1000 ? '#FF9800' : '#F44336',
            icon: 'âš¡'
          },
          {
            title: 'ç›£æ§è¦†è“‹ç‡',
            value: stats.count || '0',
            subtitle: 'æª¢æŸ¥æ¬¡æ•¸',
            color: '#2196F3',
            icon: 'ğŸ”'
          }
        ];
        
        kpiCards.forEach((kpi, index) => {
          const cardX = 50 + (index * 170);
          const cardWidth = 160;
          const cardHeight = 100;
          
          // å¡ç‰‡èƒŒæ™¯
          doc.roundedRect(cardX, kpiY, cardWidth, cardHeight, 8)
             .lineWidth(2)
             .strokeColor(kpi.color)
             .fillAndStroke('#FFFFFF', kpi.color);
          
          // åœ–æ¨™å’Œæ¨™é¡Œ
          doc.fontSize(20).fillColor(kpi.color)
             .text(kpi.icon, cardX + 10, kpiY + 10);
          
          doc.fontSize(11).fillColor('#666')
             .text(kpi.title, cardX + 40, kpiY + 15);
          
          // ä¸»è¦æ•¸å€¼
          doc.fontSize(28).fillColor(kpi.color)
             .font('NotoSansTC')
             .text(kpi.value, cardX, kpiY + 40, { width: cardWidth, align: 'center' });
          
          // å‰¯æ¨™é¡Œ
          doc.fontSize(10).fillColor('#888')
             .text(kpi.subtitle, cardX, kpiY + 75, { width: cardWidth, align: 'center' });
        });
        
        // å•é¡Œèˆ‡å»ºè­°å€å¡Š
        const issueY = 420;
        doc.fontSize(16).fillColor('#333')
           .font('NotoSansTC')
           .text('ç›£æ§æ´å¯Ÿ', 50, issueY);
        
        // æ´å¯Ÿæ¡†
        doc.roundedRect(50, issueY + 30, 500, 120, 5)
           .fillAndStroke('#F8F9FA', '#E0E0E0');
        
        // ç”Ÿæˆæ™ºèƒ½æ´å¯Ÿ
        const insights = [];
        const failureCount = calculateFailureCount(metrics);
        
        if (stats.uptime < 99.9) {
          insights.push(`â€¢ å¯ç”¨æ€§ ${stats.uptime}% ä½æ–¼ 99.9% SLA æ¨™æº–ï¼Œå»ºè­°æª¢æŸ¥ç³»çµ±ç©©å®šæ€§`);
        }
        if (stats.avgResponseTime > 1000) {
          insights.push(`â€¢ å¹³å‡å›æ‡‰æ™‚é–“ ${formatResponseTime(stats.avgResponseTime)} åé«˜ï¼Œå»ºè­°å„ªåŒ–æ€§èƒ½`);
        }
        if (stats.maxResponseTime > 5000) {
          insights.push(`â€¢ æœ€å¤§å›æ‡‰æ™‚é–“é” ${formatResponseTime(stats.maxResponseTime)}ï¼Œå¯èƒ½å­˜åœ¨æ€§èƒ½ç“¶é ¸`);
        }
        if (failureCount > 0) {
          insights.push(`â€¢ è¨˜éŒ„åˆ° ${failureCount} æ¬¡æœå‹™ä¸­æ–·ï¼Œéœ€è¦é—œæ³¨ç³»çµ±ç©©å®šæ€§`);
        }
        
        if (insights.length === 0) {
          insights.push('âœ… ç³»çµ±é‹è¡Œç‹€æ…‹è‰¯å¥½ï¼Œæ‰€æœ‰æŒ‡æ¨™å‡åœ¨æ­£å¸¸ç¯„åœå…§');
          insights.push('âœ… å»ºè­°æŒçºŒç›£æ§ä¸¦ä¿æŒç•¶å‰é‹ç¶­æ°´æº–');
        }
        
        doc.fontSize(11).fillColor('#333');
        let insightY = issueY + 45;
        insights.forEach(insight => {
          doc.text(insight, 70, insightY);
          insightY += 20;
        });
        
        // é å°¾è³‡è¨Š
        doc.fontSize(8).fillColor('#999')
           .text(`å ±è¡¨ç”Ÿæˆæ™‚é–“ï¼š${currentTime}`, 50, 720)
           .text('ç¬¬ 1 é ï¼Œå…± 2 é ', 500, 720, { width: 50, align: 'right' });
        
        // ========== ç¬¬2é ï¼šæ€§èƒ½åˆ†æ ==========
        doc.addPage();
        
        // é é¦–
        doc.rect(0, 0, doc.page.width, 3).fill('#1976D2');
        
        doc.fontSize(10).fillColor('#666')
           .text('ç¶²ç«™ç›£æ§ç³»çµ±', 50, 30)
           .text('æ€§èƒ½åˆ†æ', 450, 30, { width: 100, align: 'right' });
        
        // é é¢æ¨™é¡Œ
        doc.fontSize(20).fillColor('#333')
           .font('NotoSansTC')
           .text('æ€§èƒ½è¶¨å‹¢åˆ†æ', 50, 60);
        
        // åˆ†éš”ç·š
        doc.moveTo(50, 90)
           .lineTo(550, 90)
           .strokeColor('#E0E0E0')
           .lineWidth(0.5)
           .stroke();
        
        // å›æ‡‰æ™‚é–“è¶¨å‹¢åœ–è¡¨
        if (metrics && metrics.length > 0) {
          doc.fontSize(14).fillColor('#333')
             .font('NotoSansTC')
             .text('24å°æ™‚å›æ‡‰æ™‚é–“è¶¨å‹¢', 50, 110);
          
          drawEnhancedResponseChart(doc, metrics, 50, 150, timeRange);
          
          // åœ–è¡¨èªªæ˜
          doc.fontSize(10).fillColor('#666')
             .text('* åœ–è¡¨é¡¯ç¤ºéå»24å°æ™‚çš„å›æ‡‰æ™‚é–“è®ŠåŒ–è¶¨å‹¢', 50, 380);
        }
        
        // æ€§èƒ½æŒ‡æ¨™è©³æƒ…
        const metricsDetailY = 410;
        doc.fontSize(14).fillColor('#333')
           .font('NotoSansTC')
           .text('è©³ç´°æ€§èƒ½æŒ‡æ¨™', 50, metricsDetailY);
        
        // å‰µå»ºæ€§èƒ½æŒ‡æ¨™è¡¨æ ¼
        const perfData = [
          { label: 'æœ€å¿«å›æ‡‰æ™‚é–“', value: formatResponseTime(stats.minResponseTime), status: 'æœ€ä½³' },
          { label: 'å¹³å‡å›æ‡‰æ™‚é–“', value: formatResponseTime(stats.avgResponseTime), status: 'å…¸å‹' },
          { label: 'æœ€æ…¢å›æ‡‰æ™‚é–“', value: formatResponseTime(stats.maxResponseTime), status: 'æœ€å·®' },
          { label: 'æˆåŠŸç‡', value: `${((stats.successfulChecks/stats.count)*100).toFixed(2)}%`, status: stats.successfulChecks/stats.count > 0.999 ? 'å„ªç§€' : 'éœ€æ”¹å–„' },
          { label: 'æ•…éšœæ¬¡æ•¸', value: `${calculateFailureCount(metrics)} æ¬¡`, status: calculateFailureCount(metrics) === 0 ? 'ç„¡æ•…éšœ' : 'éœ€é—œæ³¨' },
          { label: 'é€£çºŒé‹è¡Œæ™‚é–“', value: calculateContinuousUptime(metrics), status: 'ç•¶å‰' }
        ];
        
        // è¡¨æ ¼èƒŒæ™¯
        doc.roundedRect(50, metricsDetailY + 30, 500, 180, 5)
           .fillAndStroke('#FAFAFA', '#E0E0E0');
        
        // è¡¨æ ¼å…§å®¹
        doc.fontSize(11);
        perfData.forEach((item, index) => {
          const rowY = metricsDetailY + 50 + (index * 25);
          
          // æ¨™ç±¤
          doc.fillColor('#666')
             .text(item.label, 70, rowY, { width: 150 });
          
          // æ•¸å€¼
          doc.fillColor('#333')
             .font('NotoSansTC')
             .text(item.value, 250, rowY, { width: 150, align: 'center' });
          
          // ç‹€æ…‹
          const statusColor = item.status === 'å„ªç§€' || item.status === 'ç„¡æ•…éšœ' ? '#4CAF50' :
                             item.status === 'éœ€æ”¹å–„' || item.status === 'éœ€é—œæ³¨' ? '#FF9800' : '#666';
          doc.fillColor(statusColor)
             .text(item.status, 430, rowY, { width: 100, align: 'center' });
          
          // åˆ†éš”ç·š
          if (index < perfData.length - 1) {
            doc.moveTo(70, rowY + 18)
               .lineTo(530, rowY + 18)
               .strokeColor('#E8E8E8')
               .lineWidth(0.5)
               .stroke();
          }
        });
      }
      
      // ç¸½çµå€å¡Š
      const conclusionY = 640;
      doc.fontSize(12).fillColor('#333')
         .font('NotoSansTC')
         .text('ç¸½çµ', 50, conclusionY);
      
      // ç”Ÿæˆç¸½çµæ–‡å­—
      let conclusion = '';
      if (stats.uptime >= 99.9 && stats.avgResponseTime < 500) {
        conclusion = 'ç³»çµ±æ•´é«”è¡¨ç¾å„ªç§€ï¼Œå»ºè­°ä¿æŒç•¶å‰é‹ç¶­ç­–ç•¥ã€‚';
      } else if (stats.uptime >= 99) {
        conclusion = 'ç³»çµ±é‹è¡Œç©©å®šï¼Œéƒ¨åˆ†æŒ‡æ¨™å¯é€²ä¸€æ­¥å„ªåŒ–ã€‚';
      } else {
        conclusion = 'ç³»çµ±ç©©å®šæ€§éœ€è¦æ”¹å–„ï¼Œå»ºè­°åˆ¶å®šå„ªåŒ–è¨ˆåŠƒã€‚';
      }
      
      doc.fontSize(11).fillColor('#666')
         .text(conclusion, 50, conclusionY + 20, { width: 500 });
      
      // é å°¾
      doc.fontSize(8).fillColor('#999')
         .text(`å ±è¡¨ç”Ÿæˆæ™‚é–“ï¼š${currentTime}`, 50, 720)
         .text('ç¬¬ 2 é ï¼Œå…± 2 é ', 500, 720, { width: 50, align: 'right' });
      
      // åº•éƒ¨è£é£¾ç·š
      doc.rect(0, doc.page.height - 3, doc.page.width, 3).fill('#1976D2');
      
      doc.end();
    } catch (error) {
      reject(error);
    }
  });
}

// CSVç”Ÿæˆå‡½æ•¸
function generateWebsiteCSV(website, metrics, timeRange) {
  let csv = '';
  
  // æ¨™é¡Œ
  csv += `${website.name} - ç›£æ§æ•¸æ“šå ±è¡¨\n`;
  csv += `æ™‚é–“ç¯„åœ: ${getTimeRangeText(timeRange)}\n`;
  csv += `ç”Ÿæˆæ™‚é–“: ${moment().utc().utcOffset(8).format('YYYY-MM-DD HH:mm:ss')}\n\n`;
  
  // ç¶²ç«™è³‡è¨Š
  csv += 'ç¶²ç«™è³‡è¨Š\n';
  csv += `åç¨±,${website.name}\n`;
  csv += `URL,${website.url}\n`;
  csv += `ç‹€æ…‹,${getStatusText(website.status)}\n`;
  csv += `ç›£æ§é–“éš”,${website.interval}ç§’\n\n`;
  
  // ç›£æ§æ•¸æ“šè¡¨é ­
  csv += 'ç›£æ§æ•¸æ“š\n';
  csv += 'æ™‚é–“,å›æ‡‰æ™‚é–“(ms),ç‹€æ…‹ç¢¼,DNSæ™‚é–“(ms),é€£æ¥æ™‚é–“(ms),SSLæ™‚é–“(ms),TTFB(ms),ä¸‹è¼‰æ™‚é–“(ms),å¥åº·ç‹€æ…‹\n';
  
  // ç›£æ§æ•¸æ“šå…§å®¹
  metrics.forEach(metric => {
    const time = moment(metric.time).utc().utcOffset(8).format('YYYY-MM-DD HH:mm:ss');
    const health = metric.isHealthy ? 'æ­£å¸¸' : 'ç•°å¸¸';
    csv += `${time},${metric.responseTime},${metric.statusCode},`;
    csv += `${metric.dnsTime || 0},${metric.connectTime || 0},`;
    csv += `${metric.sslHandshakeTime || 0},${metric.timeToFirstByte || 0},`;
    csv += `${metric.downloadTime || 0},${health}\n`;
  });
  
  return csv;
}

// è¼”åŠ©å‡½æ•¸
function getTimeRangeText(timeRange) {
  const ranges = {
    '1h': 'éå»1å°æ™‚',
    '3h': 'éå»3å°æ™‚',
    '6h': 'éå»6å°æ™‚',
    '12h': 'éå»12å°æ™‚',
    '24h': 'éå»24å°æ™‚',
    '2d': 'éå»2å¤©',
    '7d': 'éå»7å¤©',
    '14d': 'éå»14å¤©',
    '30d': 'éå»30å¤©',
    '90d': 'éå»90å¤©'
  };
  return ranges[timeRange] || timeRange;
}

function getStatusText(status) {
  const statusMap = {
    'healthy': 'æ­£å¸¸',
    'unhealthy': 'ç•°å¸¸',
    'pending': 'å¾…æª¢æŸ¥'
  };
  return statusMap[status] || status;
}

// æ™ºèƒ½å–®ä½æ›ç®—å‡½æ•¸
function formatResponseTime(ms) {
  if (ms === null || ms === undefined || isNaN(ms)) return 'N/A';
  
  if (ms < 1000) {
    return `${Math.round(ms)}ms`;
  } else if (ms < 60000) { // å°æ–¼1åˆ†é˜
    return `${(ms / 1000).toFixed(1)}s`;
  } else { // å¤§æ–¼1åˆ†é˜
    const minutes = Math.floor(ms / 60000);
    const seconds = Math.round((ms % 60000) / 1000);
    return seconds > 0 ? `${minutes}m${seconds}s` : `${minutes}m`;
  }
}

function formatBytes(bytes) {
  if (bytes === null || bytes === undefined || isNaN(bytes)) return 'N/A';
  
  if (bytes === 0) return '0 B';
  
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return `${(bytes / Math.pow(k, i)).toFixed(1)} ${sizes[i]}`;
}

function formatNumber(num) {
  if (num === null || num === undefined || isNaN(num)) return 'N/A';
  
  if (num < 1000) return num.toString();
  if (num < 1000000) return `${(num / 1000).toFixed(1)}K`;
  if (num < 1000000000) return `${(num / 1000000).toFixed(1)}M`;
  return `${(num / 1000000000).toFixed(1)}G`;
}

// åƒåˆ†ä½åˆ†éš”ç¬¦æ ¼å¼åŒ–
function formatNumberWithCommas(num) {
  if (num === null || num === undefined || isNaN(num)) return 'N/A';
  return num.toLocaleString('zh-TW');
}

// å°‡æ™‚é–“ç¯„åœè½‰æ›ç‚ºæ¯«ç§’
function getTimeRangeInMs(timeRange) {
  const ranges = {
    '1h': 60 * 60 * 1000,
    '3h': 3 * 60 * 60 * 1000,
    '6h': 6 * 60 * 60 * 1000,
    '12h': 12 * 60 * 60 * 1000,
    '24h': 24 * 60 * 60 * 1000,
    '2d': 2 * 24 * 60 * 60 * 1000,
    '7d': 7 * 24 * 60 * 60 * 1000,
    '14d': 14 * 24 * 60 * 60 * 1000,
    '30d': 30 * 24 * 60 * 60 * 1000,
    '90d': 90 * 24 * 60 * 60 * 1000
  };
  return ranges[timeRange] || ranges['24h'];
}

// åŸ·è¡Œæ‘˜è¦é é¢ï¼ˆé«˜å±¤ç”¨ï¼‰
function generateExecutiveSummaryPage(doc, website, stats, timeRange) {
  const timeRangeText = getTimeRangeText(timeRange);
  const currentTime = moment().utc().utcOffset(8).format('YYYY-MM-DD HH:mm:ss');
  
  // é é¦–è£é£¾ç·š
  doc.rect(0, 0, doc.page.width, 5).fill('#1976D2');
  
  // æ¨™é¡Œå€å¡Š
  doc.moveDown(2);
  doc.fontSize(28).fillColor('#1976D2')
     .font('NotoSansTC')
     .text(`${website.name}`, { align: 'center' });
  doc.fontSize(16).fillColor('#666')
     .text('åŸ·è¡Œæ‘˜è¦å ±è¡¨', { align: 'center' });
  doc.fontSize(12).fillColor('#888')
     .text(`${timeRangeText}`, { align: 'center' });
  
  doc.moveDown(1.5);
  
  // é—œéµæŒ‡æ¨™å„€è¡¨æ¿ï¼ˆå¤§è™Ÿé¡¯ç¤ºï¼‰
  doc.fontSize(18).fillColor('#1976D2')
     .text('é—œéµæ•ˆèƒ½æŒ‡æ¨™', 50, doc.y, { align: 'left' });
  
  const dashboardY = doc.y + 20;
  const cardWidth = 110;
  const cardHeight = 90;
  const cardSpacing = 15;
  
  // KPI å¡ç‰‡æ•¸æ“š
  const kpiData = [
    { 
      label: 'æœå‹™å¯ç”¨æ€§', 
      value: `${stats.uptime}%`, 
      color: stats.uptime >= 99 ? '#4CAF50' : stats.uptime >= 95 ? '#FF9800' : '#F44336',
      status: stats.uptime >= 99 ? 'å„ªç§€' : stats.uptime >= 95 ? 'è‰¯å¥½' : 'å¾…æ”¹é€²'
    },
    { 
      label: 'å¹³å‡å›æ‡‰', 
      value: formatResponseTime(stats.avgResponseTime), 
      color: stats.avgResponseTime < 500 ? '#4CAF50' : stats.avgResponseTime < 1000 ? '#FF9800' : '#F44336',
      status: stats.avgResponseTime < 500 ? 'å¿«é€Ÿ' : stats.avgResponseTime < 1000 ? 'æ­£å¸¸' : 'è¼ƒæ…¢'
    },
    { 
      label: 'æª¢æŸ¥æ¬¡æ•¸', 
      value: formatNumber(stats.count), 
      color: '#2196F3',
      status: 'æ­£å¸¸'
    },
    { 
      label: 'äº‹ä»¶æ•¸é‡', 
      value: stats.incidents || 0, 
      color: (stats.incidents || 0) === 0 ? '#4CAF50' : '#F44336',
      status: (stats.incidents || 0) === 0 ? 'ç©©å®š' : 'éœ€é—œæ³¨'
    }
  ];
  
  kpiData.forEach((kpi, index) => {
    const x = 50 + (index * (cardWidth + cardSpacing));
    
    // å¡ç‰‡èƒŒæ™¯
    doc.roundedRect(x, dashboardY, cardWidth, cardHeight, 8)
       .fillColor('#FFFFFF')
       .fill()
       .strokeColor('#E0E0E0')
       .lineWidth(1)
       .stroke();
    
    // ç‹€æ…‹æŒ‡ç¤ºå™¨
    doc.circle(x + cardWidth - 15, dashboardY + 15, 6)
       .fillColor(kpi.color)
       .fill();
    
    // æ•¸å€¼ï¼ˆå¤§å­—é«”ï¼‰
    doc.fontSize(24)
       .fillColor(kpi.color)
       .font('NotoSansTC')
       .text(String(kpi.value), x + 10, dashboardY + 20, { 
         width: cardWidth - 20, 
         align: 'center' 
       });
    
    // æ¨™ç±¤
    doc.fontSize(10)
       .fillColor('#666')
       .text(kpi.label, x + 10, dashboardY + 50, { 
         width: cardWidth - 20, 
         align: 'center' 
       });
    
    // ç‹€æ…‹æ–‡å­—
    doc.fontSize(8)
       .fillColor('#888')
       .text(kpi.status, x + 10, dashboardY + 65, { 
         width: cardWidth - 20, 
         align: 'center' 
       });
  });
  
  doc.y = dashboardY + cardHeight + 30;
  
  // è¶¨å‹¢åœ–è¡¨å€åŸŸï¼ˆç°¡åŒ–ç‰ˆï¼‰
  doc.fontSize(18).fillColor('#1976D2')
     .text('æœå‹™è¶¨å‹¢', 50, doc.y, { align: 'left' });
  
  // å¯ç”¨æ€§ç”œç”œåœˆåœ–ï¼ˆå¤§ç‰ˆï¼‰
  drawModernUptimeChart(doc, stats.uptime, 150, doc.y + 30);
  
  doc.y = doc.y + 200;
  
  // åŸ·è¡Œå»ºè­°
  doc.fontSize(18).fillColor('#1976D2')
     .text('åŸ·è¡Œå»ºè­°', 50, doc.y, { align: 'left' });
  
  const recommendationY = doc.y + 20;
  doc.roundedRect(50, recommendationY, 500, 80, 5)
     .fillColor('#F8F9FA')
     .fill()
     .strokeColor('#E0E0E0')
     .stroke();
  
  doc.fontSize(11)
     .fillColor('#333')
     .text(getExecutiveRecommendations(stats), 65, recommendationY + 15, { 
       width: 470, 
       align: 'left' 
     });
}

// ç”ŸæˆåŸ·è¡Œå»ºè­°
function getExecutiveRecommendations(stats) {
  const recommendations = [];
  
  if (stats.uptime < 99) {
    recommendations.push('â€¢ æœå‹™å¯ç”¨æ€§ä½æ–¼æ¥­ç•Œæ¨™æº–ï¼Œå»ºè­°æª¢æŸ¥åŸºç¤è¨­æ–½ç©©å®šæ€§');
  }
  if (stats.avgResponseTime > 1000) {
    recommendations.push('â€¢ å›æ‡‰æ™‚é–“è¼ƒæ…¢ï¼Œå»ºè­°å„ªåŒ–ä¼ºæœå™¨æ•ˆèƒ½æˆ–å¢åŠ è³‡æº');
  }
  if (stats.uptime >= 99.5 && stats.avgResponseTime < 500) {
    recommendations.push('â€¢ æœå‹™è¡¨ç¾å„ªç§€ï¼Œå»ºè­°ç¶­æŒç•¶å‰é‹ç‡Ÿç­–ç•¥');
  }
  if ((stats.incidents || 0) > 0) {
    recommendations.push('â€¢ ç™¼ç¾æœå‹™äº‹ä»¶ï¼Œå»ºè­°æª¢æŸ¥ç›£æ§æ—¥èªŒä¸¦åˆ¶å®šé é˜²æªæ–½');
  }
  
  if (recommendations.length === 0) {
    recommendations.push('â€¢ æœå‹™é‹è¡Œè‰¯å¥½ï¼Œå»ºè­°æŒçºŒç›£æ§é—œéµæŒ‡æ¨™');
  }
  
  return recommendations.join('\n');
}

// æŠ€è¡“è©³ç´°é é¢ï¼ˆå·¥ç¨‹å¸«ç”¨ï¼‰
function generateTechnicalDetailsPages(doc, website, stats, metrics, timeRange) {
  // æ–°é é¢
  doc.addPage();
  
  // æŠ€è¡“å ±è¡¨æ¨™é¡Œ
  doc.fontSize(20).fillColor('#1976D2')
     .font('NotoSansTC')
     .text('æŠ€è¡“è©³ç´°å ±è¡¨', 50, 50, { align: 'left' });
  
  doc.fontSize(12).fillColor('#666')
     .text('å·¥ç¨‹åœ˜éšŠå°ˆç”¨æŠ€è¡“æ•¸æ“š', 50, doc.y + 5, { align: 'left' });
  
  doc.y = doc.y + 30;
  
  // è©³ç´°çµ±è¨ˆè¡¨æ ¼
  generateDetailedStatsSection(doc, stats);
  
  // å›æ‡‰æ™‚é–“è¶¨å‹¢åœ–è¡¨ç§»åˆ°æ–°çš„ä¸€é 
  if (metrics && metrics.length > 0) {
    doc.addPage(); // æ–°å¢ä¸€é 
    
    // ç§»é™¤ã€Œå›æ‡‰æ™‚é–“çµ„æˆåˆ†æ (ms)ã€æ¨™é¡Œï¼Œç›´æ¥ç¹ªè£½åœ–è¡¨
    drawEnhancedResponseChart(doc, metrics, 50, 50, timeRange);
    doc.y = 280; // è¨­å®šé é¢åº•éƒ¨ä½ç½®
  }
  
  // ç›£æ§æ•¸æ“šè¡¨æ ¼
  generateMonitoringDataTable(doc, metrics);
}

// è©³ç´°çµ±è¨ˆå€æ®µ
function generateDetailedStatsSection(doc, stats) {
  doc.fontSize(16).fillColor('#1976D2')
     .text('è©³ç´°çµ±è¨ˆæ•¸æ“š', 50, doc.y, { align: 'left' });
  
  const statsY = doc.y + 20;
  
  // çµ±è¨ˆèƒŒæ™¯
  doc.rect(50, statsY, 500, 120)
     .fillColor('#FAFAFA')
     .fill()
     .strokeColor('#E0E0E0')
     .stroke();
  
  // çµ±è¨ˆé …ç›®ï¼ˆä¸‰æ¬„ä½ˆå±€ï¼‰
  doc.fillColor('#333').fontSize(10);
  
  const col1 = 65, col2 = 230, col3 = 395;
  let rowY = statsY + 20;
  
  // ç¬¬ä¸€è¡Œ
  doc.text(`æª¢æŸ¥ç¸½æ•¸: ${formatNumberWithCommas(stats.count)}`, col1, rowY);
  doc.text(`æˆåŠŸæª¢æŸ¥: ${formatNumberWithCommas(stats.successfulChecks)}`, col2, rowY);
  doc.text(`å¤±æ•—æª¢æŸ¥: ${formatNumberWithCommas(stats.count - stats.successfulChecks)}`, col3, rowY);
  
  rowY += 25;
  doc.text(`æœ€å¿«å›æ‡‰: ${formatResponseTime(stats.minResponseTime)}`, col1, rowY);
  doc.text(`æœ€æ…¢å›æ‡‰: ${formatResponseTime(stats.maxResponseTime)}`, col2, rowY);
  doc.text(`å›æ‡‰ä¸­ä½æ•¸: ${formatResponseTime(stats.medianResponseTime || stats.avgResponseTime)}`, col3, rowY);
  
  rowY += 25;
  doc.text(`å¯ç”¨æ€§: ${stats.uptime}%`, col1, rowY);
  doc.text(`åœæ©Ÿæ™‚é–“: ${stats.downtime}`, col2, rowY);
  doc.text(`æˆåŠŸç‡: ${((stats.successfulChecks/stats.count)*100).toFixed(2)}%`, col3, rowY);
  
  doc.y = statsY + 140;
}

// ç›£æ§æ•¸æ“šè¡¨æ ¼
function generateMonitoringDataTable(doc, metrics) {
  if (!metrics || metrics.length === 0) return;
  
  doc.fontSize(16).fillColor('#1976D2')
     .text('è¿‘æœŸç›£æ§è¨˜éŒ„', 50, doc.y, { align: 'left' });
  
  const tableY = doc.y + 20;
  const displayMetrics = metrics.slice(-15); // é¡¯ç¤ºæœ€è¿‘15ç­†
  const rowHeight = 18;
  const tableHeight = (displayMetrics.length + 1) * rowHeight;
  
  // è¡¨æ ¼èƒŒæ™¯
  doc.rect(50, tableY, 500, tableHeight)
     .fillColor('#FFFFFF')
     .fill()
     .strokeColor('#CCCCCC')
     .stroke();
  
  // è¡¨é ­
  const headerY = tableY + 5;
  doc.rect(50, headerY, 500, rowHeight - 2)
     .fillColor('#1976D2')
     .fill();
  
  doc.fillColor('#FFFFFF').fontSize(9).font('NotoSansTC');
  doc.text('æª¢æŸ¥æ™‚é–“', 60, headerY + 6);
  doc.text('å›æ‡‰æ™‚é–“', 160, headerY + 6);
  doc.text('ç‹€æ…‹ç¢¼', 240, headerY + 6);
  doc.text('DNS', 300, headerY + 6);
  doc.text('é€£æ¥', 340, headerY + 6);
  doc.text('SSL', 380, headerY + 6);
  doc.text('TTFB', 420, headerY + 6);
  doc.text('ç‹€æ…‹', 480, headerY + 6);
  
  // æ•¸æ“šè¡Œ
  displayMetrics.forEach((metric, index) => {
    const rowY = headerY + (index + 1) * rowHeight + 6;
    const bgColor = index % 2 === 0 ? '#F9F9F9' : '#FFFFFF';
    
    // è¡ŒèƒŒæ™¯
    doc.rect(50, rowY - 3, 500, rowHeight - 2)
       .fillColor(bgColor)
       .fill();
    
    // æ™‚é–“
    const timeStr = moment(metric.timestamp).utc().utcOffset(8).format('MM/DD HH:mm');
    doc.fillColor('#333').fontSize(8)
       .text(timeStr, 60, rowY);
    
    // å›æ‡‰æ™‚é–“ï¼ˆè‘—è‰²ï¼‰
    const rtColor = metric.responseTime < 500 ? '#4CAF50' : 
                    metric.responseTime < 1000 ? '#FF9800' : '#F44336';
    doc.fillColor(rtColor)
       .text(formatResponseTime(metric.responseTime), 160, rowY);
    
    // ç‹€æ…‹ç¢¼
    const statusColor = metric.statusCode >= 200 && metric.statusCode < 300 ? '#4CAF50' : '#F44336';
    doc.fillColor(statusColor)
       .text(String(metric.statusCode), 240, rowY);
    
    // å…¶ä»–æŠ€è¡“æŒ‡æ¨™
    doc.fillColor('#666').fontSize(7);
    doc.text(metric.dnsTime ? `${metric.dnsTime}ms` : '-', 300, rowY);
    doc.text(metric.connectTime ? `${metric.connectTime}ms` : '-', 340, rowY);
    doc.text(metric.sslTime ? `${metric.sslTime}ms` : '-', 380, rowY);
    doc.text(metric.ttfbTime ? `${metric.ttfbTime}ms` : '-', 420, rowY);
    
    // å¥åº·ç‹€æ…‹
    const healthIcon = metric.statusCode >= 200 && metric.statusCode < 300 ? 'âœ“' : 'âœ—';
    const healthColor = metric.statusCode >= 200 && metric.statusCode < 300 ? '#4CAF50' : '#F44336';
    doc.fillColor(healthColor).fontSize(8)
       .text(healthIcon, 490, rowY);
  });
  
  doc.y = tableY + tableHeight + 20;
}

// åˆ†å±¤å¼ PDF ç”Ÿæˆå‡½æ•¸ï¼ˆæ–°ç‰ˆæœ¬ï¼‰
async function generateLayeredWebsitePDF(website, stats, metrics, timeRange) {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({ 
        margin: 50,
        lineGap: 3,  // å¢åŠ è¡Œé–“è·
        wordSpacing: 1.2,  // å¢åŠ å­—é–“è·
        characterSpacing: 0.8,  // å¢åŠ å­—å…ƒé–“è·
        info: {
          Title: `${website.name} åˆ†å±¤ç›£æ§å ±è¡¨`,
          Author: 'Website Monitor System v3.2.0',
          Subject: 'åˆ†å±¤å¼ç¶²ç«™ç›£æ§æ•¸æ“šå ±è¡¨ï¼ˆåŸ·è¡Œæ‘˜è¦ + æŠ€è¡“è©³æƒ…ï¼‰'
        }
      });
      const chunks = [];
      
      doc.on('data', (chunk) => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      
      // è¨»å†Šä¸­æ–‡å­—é«”
      const fontPath = '/app/fonts/NotoSansTC.ttf';
      if (fs.existsSync(fontPath)) {
        console.log('ä½¿ç”¨ Noto Sans TC ä¸­æ–‡å­—é«”');
        doc.registerFont('NotoSansTC', fontPath);
        doc.font('NotoSansTC');
      } else {
        console.log('æ‰¾ä¸åˆ°ä¸­æ–‡å­—é«”æª”æ¡ˆï¼Œä½¿ç”¨é è¨­å­—é«”');
      }
      
      // ç¬¬ä¸€é ï¼šåŸ·è¡Œæ‘˜è¦ï¼ˆé«˜å±¤ä¸»ç®¡ç”¨ï¼‰
      generateExecutiveSummaryPage(doc, website, stats, timeRange);
      
      // å·²æ•´åˆåˆ°ç¬¬1é å’Œç¬¬2é ï¼Œä¸éœ€è¦é¡å¤–çš„æŠ€è¡“é é¢
      
      // å…¨åŸŸé å°¾
      const currentTime = moment().utc().utcOffset(8).format('YYYY-MM-DD HH:mm:ss');
      try {
        const pages = doc.bufferedPageRange();
        for (let i = 0; i < pages.count; i++) {
          doc.switchToPage(i);
          
          // é é¢é¡å‹æ¨™è­˜
          const pageType = i === 0 ? 'åŸ·è¡Œæ‘˜è¦' : 'æŠ€è¡“å ±è¡¨';
          const audienceType = i === 0 ? 'ä¸»ç®¡å±¤' : 'å·¥ç¨‹å¸«';
          
          // å·¦å´ï¼šå ±è¡¨é¡å‹
          doc.fontSize(8)
             .fillColor('#666')
             .text(`${pageType} (${audienceType}) | ç¶²ç«™ç›£æ§ç³»çµ± v3.2.0`, 50, doc.page.height - 30, { 
               align: 'left' 
             });
          
          // å³å´ï¼šé ç¢¼å’Œæ™‚é–“
          doc.text(`ç¬¬ ${i + 1} é  | ${currentTime}`, 0, doc.page.height - 30, { 
            align: 'right' 
          });
        }
      } catch (footerError) {
        console.log('é å°¾ç”Ÿæˆç•¥é:', footerError.message);
      }
      
      doc.end();
      
    } catch (error) {
      console.error('PDF ç”ŸæˆéŒ¯èª¤:', error);
      reject(error);
    }
  });
}

// æ€§èƒ½è¶¨å‹¢åˆ†æå„€è¡¨æ¿ - é¡¯ç¤ºä¸åŒç¶­åº¦çš„æŒ‡æ¨™
function drawTrendGauges(doc, stats, metrics, startX, startY) {
  const gaugeSize = 60;
  const spacing = 170;
  
  // è¨ˆç®—è¶¨å‹¢å’Œå¥åº·åº¦æŒ‡æ¨™
  const performanceScore = calculatePerformanceScore(stats, metrics);
  const stabilityIndex = calculateStabilityIndex(metrics);
  const responseHealth = calculateResponseHealth(stats);
  
  // ä¸‰å€‹ä¸åŒç¶­åº¦çš„æŒ‡æ¨™
  const gauges = [
    {
      title: 'æ€§èƒ½è©•åˆ†',
      value: performanceScore,
      max: 100,
      unit: 'åˆ†',
      color: '#9C27B0',
      x: startX + 70,
      threshold: { good: 85, warning: 70 }
    },
    {
      title: 'ç©©å®šæ€§æŒ‡æ•¸',
      value: stabilityIndex,
      max: 100,
      unit: '%', 
      color: '#607D8B',
      x: startX + 70 + spacing,
      threshold: { good: 90, warning: 75 }
    },
    {
      title: 'å›æ‡‰å¥åº·åº¦',
      value: responseHealth,
      max: 100,
      unit: '%',
      color: '#795548',
      x: startX + 70 + spacing * 2,
      threshold: { good: 80, warning: 60 }
    }
  ];
  
  gauges.forEach(gauge => {
    drawSemiCircleGauge(doc, gauge.x, startY + 40, gaugeSize, gauge.value, gauge.max, gauge.color, gauge.title, gauge.unit, gauge.threshold);
  });
}

// è¨ˆç®—æ€§èƒ½ç¶œåˆè©•åˆ†
function calculatePerformanceScore(stats, metrics) {
  if (!stats) return 0;
  
  // åŸºæ–¼å¯ç”¨æ€§ã€å›æ‡‰æ™‚é–“å’ŒæˆåŠŸç‡çš„ç¶œåˆè©•åˆ†
  const uptimeScore = Math.min(stats.uptime || 0, 100);
  const responseScore = Math.max(0, 100 - (stats.avgResponseTime || 1000) / 10); // 1ç§’=90åˆ†
  const successScore = ((stats.successfulChecks || 0) / Math.max(stats.count || 1, 1)) * 100;
  
  return Math.round((uptimeScore * 0.4 + responseScore * 0.3 + successScore * 0.3));
}

// è¨ˆç®—ç©©å®šæ€§æŒ‡æ•¸ï¼ˆåŸºæ–¼å›æ‡‰æ™‚é–“çš„è®Šç•°ç¨‹åº¦ï¼‰
function calculateStabilityIndex(metrics) {
  if (!metrics || metrics.length < 5) return 0;
  
  const responseTimes = metrics
    .filter(m => m.responseTime && m.responseTime > 0)
    .map(m => m.responseTime)
    .slice(-20); // å–æœ€è¿‘20å€‹æ•¸æ“šé»
  
  if (responseTimes.length < 5) return 0;
  
  const mean = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;
  const variance = responseTimes.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / responseTimes.length;
  const stdDev = Math.sqrt(variance);
  
  // è®Šç•°ä¿‚æ•¸è¶Šå°ï¼Œç©©å®šæ€§è¶Šé«˜
  const coefficientOfVariation = stdDev / mean;
  const stabilityIndex = Math.max(0, 100 - (coefficientOfVariation * 100));
  
  return Math.round(stabilityIndex);
}

// è¨ˆç®—å›æ‡‰å¥åº·åº¦ï¼ˆåŸºæ–¼æœ€è¿‘çš„æ€§èƒ½è¡¨ç¾ï¼‰
function calculateResponseHealth(stats) {
  if (!stats) return 0;
  
  const avgResponse = stats.avgResponseTime || 1000;
  const minResponse = stats.minResponseTime || avgResponse;
  const maxResponse = stats.maxResponseTime || avgResponse;
  
  // åŸºæ–¼å¹³å‡å›æ‡‰æ™‚é–“å’Œè®ŠåŒ–ç¯„åœ
  const responseRatio = minResponse / Math.max(maxResponse, 1);
  const avgHealth = Math.max(0, 100 - avgResponse / 20); // 2ç§’=0åˆ†
  const consistencyBonus = responseRatio * 20; // ä¸€è‡´æ€§çå‹µ
  
  return Math.min(100, Math.round(avgHealth + consistencyBonus));
}

// åŸå„€è¡¨æ¿å‡½æ•¸ï¼ˆä¿ç•™å‚™ç”¨ï¼‰
function drawDashboardGauges(doc, stats, startX, startY) {
  const gaugeSize = 60;  // ç¸®å°å„€è¡¨ç›¤å°ºå¯¸ä»¥é¿å…é‡ç–Š
  const spacing = 170;   // å¢åŠ é–“è·ä»¥ç¢ºä¿ä¸é‡ç–Š
  
  // ä¸‰å€‹æ ¸å¿ƒæŒ‡æ¨™å„€è¡¨
  const gauges = [
    {
      title: 'å¯ç”¨æ€§',
      value: stats.uptime,
      max: 100,
      unit: '%',
      color: '#4CAF50',
      x: startX + 70,
      threshold: { good: 99, warning: 95 }
    },
    {
      title: 'å¹³å‡å›æ‡‰',
      value: stats.avgResponseTime,
      max: 2000,
      unit: 'ms', 
      color: '#2196F3',
      x: startX + 70 + spacing,
      threshold: { good: 200, warning: 500 }
    },
    {
      title: 'æˆåŠŸç‡',
      value: (stats.successfulChecks/stats.count)*100,
      max: 100,
      unit: '%',
      color: '#FF9800',
      x: startX + 70 + spacing * 2,
      threshold: { good: 98, warning: 90 }
    }
  ];
  
  gauges.forEach(gauge => {
    drawSemiCircleGauge(doc, gauge.x, startY + 40, gaugeSize, gauge.value, gauge.max, gauge.color, gauge.title, gauge.unit, gauge.threshold);
  });
}

// åŠåœ“å½¢å„€è¡¨ç›¤
function drawSemiCircleGauge(doc, centerX, centerY, radius, value, maxValue, color, title, unit, threshold) {
  const percentage = Math.min(value / maxValue, 1);
  const angle = Math.PI * percentage; // åŠåœ“ç¯„åœ
  
  doc.save();
  
  // èƒŒæ™¯å¼§ç·š
  doc.strokeColor('#E0E0E0').lineWidth(8);
  doc.arc(centerX, centerY, radius, Math.PI, 0, false).stroke();
  
  // æ•¸å€¼å¼§ç·š - æ ¹æ“šé–¾å€¼è¨­å®šé¡è‰²
  let gaugeColor = color;
  if (unit === '%') {
    if (value >= threshold.good) gaugeColor = '#4CAF50';
    else if (value >= threshold.warning) gaugeColor = '#FF9800';
    else gaugeColor = '#F44336';
  } else {
    if (value <= threshold.good) gaugeColor = '#4CAF50';
    else if (value <= threshold.warning) gaugeColor = '#FF9800';
    else gaugeColor = '#F44336';
  }
  
  doc.strokeColor(gaugeColor).lineWidth(8);
  doc.arc(centerX, centerY, radius, Math.PI, Math.PI + angle, false).stroke();
  
  // ä¸­å¿ƒæ•¸å€¼
  doc.fillColor('#333').fontSize(18).font('NotoSansTC');
  const displayValue = unit === 'ms' ? Math.round(value) : value.toFixed(1);
  const textWidth = doc.widthOfString(displayValue + unit);
  doc.text(displayValue + unit, centerX - textWidth/2, centerY - 5);
  
  // æ¨™é¡Œ
  doc.fillColor('#666').fontSize(12);
  const titleWidth = doc.widthOfString(title);
  doc.text(title, centerX - titleWidth/2, centerY + 25);
  
  // åˆ»åº¦æ¨™è¨˜
  doc.strokeColor('#CCC').lineWidth(1);
  for (let i = 0; i <= 4; i++) {
    const tickAngle = Math.PI + (Math.PI * i / 4);
    const innerRadius = radius - 5;
    const outerRadius = radius + 5;
    
    const x1 = centerX + Math.cos(tickAngle) * innerRadius;
    const y1 = centerY + Math.sin(tickAngle) * innerRadius;
    const x2 = centerX + Math.cos(tickAngle) * outerRadius;
    const y2 = centerY + Math.sin(tickAngle) * outerRadius;
    
    doc.moveTo(x1, y1).lineTo(x2, y2).stroke();
  }
  
  doc.restore();
}

// æœˆåº¦å¯ç”¨æ€§æ—¥æ›†è¦–åœ–
function drawMonthlyAvailabilityCalendar(doc, metrics, startX, startY, timeRange) {
  const now = moment();
  const currentMonth = now.clone().startOf('month');
  const daysInMonth = currentMonth.daysInMonth();
  const firstDayOfWeek = currentMonth.day(); // 0=Sunday, 1=Monday, etc.
  
  const cellSize = 60;
  const cellSpacing = 5;
  const calendarWidth = 7 * (cellSize + cellSpacing) - cellSpacing;
  
  // æ—¥æ›†æ¨™é¡Œ
  doc.fontSize(16).fillColor('#333').font('NotoSansTC');
  const monthTitle = now.format('YYYYå¹´MMæœˆ') + ' å¯ç”¨æ€§æ¦‚è¦½';
  doc.text(monthTitle, startX + calendarWidth/2 - doc.widthOfString(monthTitle)/2, startY);
  
  // æ˜ŸæœŸæ¨™é¡Œ
  const weekDays = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'];
  doc.fontSize(12).fillColor('#666');
  weekDays.forEach((day, index) => {
    const x = startX + index * (cellSize + cellSpacing) + cellSize/2;
    doc.text(day, x - doc.widthOfString(day)/2, startY + 30);
  });
  
  // è™•ç†ç›£æ§æ•¸æ“šï¼Œè¨ˆç®—æ¯æ—¥å¯ç”¨æ€§
  const dailyStats = {};
  
  // åˆå§‹åŒ–æ‰€æœ‰æ—¥æœŸ
  for (let day = 1; day <= daysInMonth; day++) {
    const dateKey = currentMonth.clone().date(day).format('YYYY-MM-DD');
    dailyStats[dateKey] = { 
      total: 0, 
      successful: 0, 
      uptime: 0,
      hasData: false 
    };
  }
  
  // è™•ç†ç›£æ§æ•¸æ“š
  if (metrics && metrics.length > 0) {
    metrics.forEach(metric => {
      const timestamp = moment(metric.timestamp || metric.time);
      if (timestamp.isValid() && timestamp.month() === now.month()) {
        const dateKey = timestamp.format('YYYY-MM-DD');
        if (dailyStats[dateKey]) {
          dailyStats[dateKey].total++;
          dailyStats[dateKey].hasData = true;
          if (metric.status === 'healthy' || metric.isHealthy !== false) {
            dailyStats[dateKey].successful++;
          }
        }
      }
    });
    
    // è¨ˆç®—æ¯æ—¥å¯ç”¨æ€§
    Object.keys(dailyStats).forEach(dateKey => {
      const stats = dailyStats[dateKey];
      if (stats.total > 0) {
        stats.uptime = (stats.successful / stats.total) * 100;
      } else if (!stats.hasData) {
        stats.uptime = null; // ç„¡æ•¸æ“š
      }
    });
  }
  
  // ç¹ªè£½æ—¥æ›†æ ¼å­
  let currentRow = 0;
  let currentCol = firstDayOfWeek;
  
  for (let day = 1; day <= daysInMonth; day++) {
    const x = startX + currentCol * (cellSize + cellSpacing);
    const y = startY + 60 + currentRow * (cellSize + cellSpacing);
    
    const dateKey = currentMonth.clone().date(day).format('YYYY-MM-DD');
    const dayStats = dailyStats[dateKey];
    
    // æ±ºå®šæ ¼å­é¡è‰²
    let cellColor = '#F5F5F5'; // ç„¡æ•¸æ“š - ç°è‰²
    let textColor = '#999';
    
    if (dayStats.hasData) {
      if (dayStats.uptime === null) {
        cellColor = '#F5F5F5'; // ç„¡æ•¸æ“š
        textColor = '#999';
      } else if (dayStats.uptime >= 99) {
        cellColor = '#4CAF50'; // å„ªç§€ - ç¶ è‰²
        textColor = '#FFF';
      } else if (dayStats.uptime >= 95) {
        cellColor = '#FF9800'; // è­¦å‘Š - æ©™è‰²
        textColor = '#FFF';
      } else {
        cellColor = '#F44336'; // ç•°å¸¸ - ç´…è‰²
        textColor = '#FFF';
      }
    }
    
    // ç¹ªè£½æ ¼å­
    doc.roundedRect(x, y, cellSize, cellSize, 3)
       .fillColor(cellColor)
       .fill()
       .strokeColor('#E0E0E0')
       .lineWidth(1)
       .stroke();
    
    // æ—¥æœŸæ•¸å­—
    doc.fontSize(14).fillColor(textColor).font('NotoSansTC');
    const dayText = day.toString();
    const dayTextWidth = doc.widthOfString(dayText);
    doc.text(dayText, x + cellSize/2 - dayTextWidth/2, y + 12);
    
    // å¯ç”¨æ€§ç™¾åˆ†æ¯”ï¼ˆå¦‚æœæœ‰æ•¸æ“šï¼‰
    if (dayStats.hasData && dayStats.uptime !== null) {
      doc.fontSize(8).fillColor(textColor);
      const uptimeText = dayStats.uptime.toFixed(0) + '%';
      const uptimeWidth = doc.widthOfString(uptimeText);
      doc.text(uptimeText, x + cellSize/2 - uptimeWidth/2, y + 32);
    }
    
    currentCol++;
    if (currentCol >= 7) {
      currentCol = 0;
      currentRow++;
    }
  }
  
  // åœ–ä¾‹
  const legendY = startY + 60 + (currentRow + 1) * (cellSize + cellSpacing) + 20;
  const legendItems = [
    { color: '#4CAF50', label: 'å„ªç§€ (â‰¥99%)', textColor: '#FFF' },
    { color: '#FF9800', label: 'è­¦å‘Š (95-99%)', textColor: '#FFF' },
    { color: '#F44336', label: 'ç•°å¸¸ (<95%)', textColor: '#FFF' },
    { color: '#F5F5F5', label: 'ç„¡æ•¸æ“š', textColor: '#999' }
  ];
  
  doc.fontSize(10).fillColor('#666').font('NotoSansTC');
  doc.text('åœ–ä¾‹ï¼š', startX, legendY);
  
  legendItems.forEach((item, index) => {
    const itemX = startX + 50 + index * 120;
    
    // è‰²å¡Š
    doc.roundedRect(itemX, legendY - 3, 15, 15, 2)
       .fillColor(item.color)
       .fill();
    
    // æ¨™ç±¤
    doc.fillColor('#666').text(item.label, itemX + 20, legendY);
  });
}

// é—œéµæ•ˆèƒ½æŒ‡æ¨™å¡ç‰‡ - ç°¡åŒ–ç‰ˆæœ¬ï¼Œç§»é™¤æ™‚é–“è»¸
function drawKeyMetricsCards(doc, stats, metrics, startX, startY, timeRange) {
  // è¨ˆç®—æ•…éšœçµ±è¨ˆ
  const failureCount = calculateFailureCount(metrics);
  const uptime = stats.uptime || 100;
  const totalHours = getTimeRangeHours(timeRange);
  const continuousUptime = calculateContinuousUptime(metrics);
  
  // ç›´æ¥ç¹ªè£½ä¸‰å€‹é—œéµæŒ‡æ¨™å¡ç‰‡ï¼Œæ›´å¤§æ›´æ¸…æ™°
  const cardWidth = 150;
  const cardHeight = 80;
  const cardSpacing = 10;
  const totalWidth = (cardWidth * 3) + (cardSpacing * 2);
  const centerX = (doc.page.width - totalWidth) / 2;
  
  // å¡ç‰‡1ï¼šå¯ç”¨æ€§
  const card1X = centerX;
  doc.roundedRect(card1X, startY, cardWidth, cardHeight, 5)
     .fillAndStroke('#E8F5E9', '#4CAF50');
  
  doc.fontSize(12).fillColor('#4CAF50').font('NotoSansTC');
  doc.text('å¯ç”¨æ€§', card1X, startY + 10, { width: cardWidth, align: 'center' });
  
  doc.fontSize(32).fillColor('#2E7D32').font('NotoSansTC');
  doc.text(`${uptime}%`, card1X, startY + 30, { width: cardWidth, align: 'center' });
  
  doc.fontSize(10).fillColor('#666');
  doc.text(`éå»${totalHours}å°æ™‚`, card1X, startY + 62, { width: cardWidth, align: 'center' });
  
  // å¡ç‰‡2ï¼šæ•…éšœæ¬¡æ•¸
  const card2X = centerX + cardWidth + cardSpacing;
  const cardColor = failureCount === 0 ? '#E8F5E9' : '#FFEBEE';
  const textColor = failureCount === 0 ? '#4CAF50' : '#F44336';
  
  doc.roundedRect(card2X, startY, cardWidth, cardHeight, 5)
     .fillAndStroke(cardColor, textColor);
  
  doc.fontSize(12).fillColor(textColor).font('NotoSansTC');
  doc.text('æ•…éšœæ¬¡æ•¸', card2X, startY + 10, { width: cardWidth, align: 'center' });
  
  doc.fontSize(32).fillColor(textColor).font('NotoSansTC');
  doc.text(failureCount.toString(), card2X, startY + 30, { width: cardWidth, align: 'center' });
  
  doc.fontSize(10).fillColor('#666');
  doc.text(failureCount === 0 ? 'ç³»çµ±ç©©å®š' : 'éœ€è¦é—œæ³¨', card2X, startY + 62, { width: cardWidth, align: 'center' });
  
  // å¡ç‰‡3ï¼šé€£çºŒé‹è¡Œ
  const card3X = centerX + (cardWidth + cardSpacing) * 2;
  doc.roundedRect(card3X, startY, cardWidth, cardHeight, 5)
     .fillAndStroke('#E3F2FD', '#2196F3');
  
  doc.fontSize(12).fillColor('#2196F3').font('NotoSansTC');
  doc.text('é€£çºŒé‹è¡Œ', card3X, startY + 10, { width: cardWidth, align: 'center' });
  
  doc.fontSize(20).fillColor('#1565C0').font('NotoSansTC');
  doc.text(continuousUptime, card3X, startY + 32, { width: cardWidth, align: 'center' });
  
  doc.fontSize(10).fillColor('#666');
  doc.text('ç„¡æ•…éšœæ™‚é–“', card3X, startY + 62, { width: cardWidth, align: 'center' });
  
  // åœ¨å¡ç‰‡ä¸‹æ–¹æ·»åŠ ç°¡è¦èªªæ˜
  doc.moveDown(2);
  doc.fontSize(10).fillColor('#888');
  const summaryY = startY + cardHeight + 20;
  
  if (failureCount === 0 && uptime >= 99.9) {
    doc.text('âœ… ç³»çµ±é‹è¡Œç‹€æ…‹å„ªç§€ï¼Œç„¡ä»»ä½•æ•…éšœè¨˜éŒ„', 50, summaryY, { width: 500, align: 'center' });
  } else if (uptime >= 99) {
    doc.text(`âš ï¸ ç³»çµ±æ•´é«”ç©©å®šï¼Œä½†è¨˜éŒ„åˆ° ${failureCount} æ¬¡çŸ­æš«ä¸­æ–·`, 50, summaryY, { width: 500, align: 'center' });
  } else {
    doc.text(`âŒ ç³»çµ±éœ€è¦å„ªåŒ–ï¼Œå¯ç”¨æ€§ä½æ–¼é æœŸæ¨™æº–`, 50, summaryY, { width: 500, align: 'center' });
  }
}

// ä¿ç•™åŸå§‹å‡½æ•¸ä»¥é˜²å…¶ä»–åœ°æ–¹èª¿ç”¨ï¼ˆä½†å·²å»¢æ£„ï¼‰
function drawServiceStabilityAnalysis(doc, stats, metrics, startX, startY, timeRange) {
  // è½‰å‘ä½¿ç”¨æ–°çš„ç°¡åŒ–ç‰ˆæœ¬
  drawKeyMetricsCards(doc, stats, metrics, startX, startY, timeRange);
}

// åŸå§‹çš„æœå‹™ç©©å®šæ€§åˆ†æå‡½æ•¸ï¼ˆå·²å»¢æ£„ï¼‰
function drawServiceStabilityAnalysis_deprecated(doc, stats, metrics, startX, startY, timeRange) {
  const sectionWidth = 500;
  const sectionHeight = 180;
  
  // è¨ˆç®—æ•…éšœçµ±è¨ˆ
  const failureCount = calculateFailureCount(metrics);
  const uptime = stats.uptime || 100;
  const totalHours = getTimeRangeHours(timeRange);
  const downtimeMinutes = Math.round((100 - uptime) * totalHours * 60 / 100);
  const continuousUptime = calculateContinuousUptime(metrics);
  
  // ç§»é™¤é‡è¤‡çš„æ¨™é¡Œï¼Œå› ç‚ºå·²ç¶“åœ¨ä¸»å‡½æ•¸ä¸­è¨­å®šäº†
  // ç›´æ¥å¾startYé–‹å§‹ç¹ªè£½æ™‚é–“è»¸
  
  // é‡æ–°è¨­è¨ˆæ™‚é–“è»¸ä½ˆå±€ - ä½¿ç”¨æ›´æ¸…æ™°çš„åˆ†é›¢
  const timelineY = startY + 20;  // æ¸›å°‘é–“è·ï¼Œå› ç‚ºæ²’æœ‰é‡è¤‡æ¨™é¡Œäº†
  const timelineX = startX + 100;  // èª¿æ•´å·¦å´ç©ºé–“
  const timelineWidth = 280;      // èª¿æ•´æ™‚é–“è»¸å¯¬åº¦
  const timelineHeight = 25;      // ä¿æŒæ™‚é–“è»¸é«˜åº¦
  
  // è¨ˆç®—æ™‚é–“
  const startTime = moment().subtract(totalHours, 'hours');
  const endTime = moment();
  
  // é–‹å§‹æ™‚é–“æ¨™ç±¤ - å·¦å´å°é½Š
  doc.fontSize(10).fillColor('#666').font('NotoSansTC');
  doc.text('é–‹å§‹æ™‚é–“', startX, timelineY - 15, { width: 80, align: 'center' });
  doc.fontSize(11).fillColor('#1976D2');
  doc.text(startTime.format('HH:mm'), startX, timelineY + 2, { width: 80, align: 'center' });
  
  // ç¹ªè£½æ™‚é–“è»¸èƒŒæ™¯ï¼ˆç°è‰²ï¼‰
  doc.roundedRect(timelineX, timelineY, timelineWidth, timelineHeight, 4)
     .fillColor('#E0E0E0')
     .fill();
  
  // ç¹ªè£½æ­£å¸¸é‹è¡Œéƒ¨åˆ†ï¼ˆç¶ è‰²ï¼‰
  const uptimeWidth = (uptime / 100) * timelineWidth;
  doc.roundedRect(timelineX, timelineY, uptimeWidth, timelineHeight, 4)
     .fillColor('#4CAF50')
     .fill();
  
  // çµæŸæ™‚é–“æ¨™ç±¤ - å³å´å°é½Š
  const endTimeX = timelineX + timelineWidth + 10;
  doc.fontSize(10).fillColor('#666').font('NotoSansTC');
  doc.text('çµæŸæ™‚é–“', endTimeX, timelineY - 15, { width: 80, align: 'center' });
  doc.fontSize(11).fillColor('#1976D2');
  doc.text(endTime.format('HH:mm'), endTimeX, timelineY + 2, { width: 80, align: 'center' });
  
  // æ™‚é–“è»¸ä¸­å¤®æ¨™ç±¤ - æ•¸æ“š
  doc.fontSize(10).fillColor('#666').font('NotoSansTC');
  doc.text('æ•¸æ“š', timelineX + timelineWidth / 2 - 40, timelineY - 15, { width: 80, align: 'center' });
  doc.fontSize(13).fillColor('#4CAF50').font('NotoSansTC');
  doc.text(`${uptime}% æ­£å¸¸é‹è¡Œ`, timelineX + timelineWidth / 2 - 40, timelineY + 2, { width: 80, align: 'center' });
  
  // ç‹€æ…‹æè¿°ï¼ˆå·¦ä¸‹è§’ï¼‰
  doc.fontSize(10).fillColor('#666');
  const statusText = failureCount === 0 ? 'âœ… ç„¡ä¸­æ–·è¨˜éŒ„' : `âš ï¸ ${failureCount}æ¬¡ä¸­æ–·`;
  doc.text(statusText, startX, timelineY + timelineHeight + 30);
  
  // ä¸‰å€‹çµ±è¨ˆå¡ç‰‡ - å£“ç¸®é«˜åº¦ç‚ºå›æ‡‰æ™‚é–“åœ–è¡¨ç•™ç©ºé–“
  const cardY = startY + 70;   // èª¿æ•´å‚ç›´é–“è·
  const cardWidth = 140;       // å¢åŠ å¡ç‰‡å¯¬åº¦ä»¥ä¾¿æ–‡å­—ç½®ä¸­
  const cardHeight = 50;       // å¢åŠ å¡ç‰‡é«˜åº¦
  const cardSpacing = 160;     // èª¿æ•´å¡ç‰‡é–“è·
  
  // å¡ç‰‡1ï¼šæ•…éšœæ¬¡æ•¸
  doc.roundedRect(startX, cardY, cardWidth, cardHeight, 5)
     .fillAndStroke(failureCount === 0 ? '#E8F5E8' : '#FFEBEE', failureCount === 0 ? '#4CAF50' : '#F44336');
  
  // ç½®ä¸­é¡¯ç¤ºæ•¸å­—
  doc.fontSize(24).fillColor(failureCount === 0 ? '#4CAF50' : '#F44336').font('NotoSansTC');
  doc.text(`${failureCount} æ¬¡æ•…éšœ`, startX, cardY + 10, { width: cardWidth, align: 'center' });
  
  // ç½®ä¸­é¡¯ç¤ºèªªæ˜æ–‡å­—
  doc.fontSize(10).fillColor('#666');
  doc.text(`éå»${totalHours}å°æ™‚`, startX, cardY + 32, { width: cardWidth, align: 'center' });
  
  // å¡ç‰‡2ï¼šé€£çºŒé‹è¡Œæ™‚é–“
  doc.roundedRect(startX + cardSpacing, cardY, cardWidth, cardHeight, 5)
     .fillAndStroke('#E3F2FD', '#2196F3');
  
  // ç½®ä¸­é¡¯ç¤ºæ™‚é–“
  doc.fontSize(18).fillColor('#2196F3').font('NotoSansTC');
  doc.text(continuousUptime, startX + cardSpacing, cardY + 10, { width: cardWidth, align: 'center' });
  
  // ç½®ä¸­é¡¯ç¤ºèªªæ˜æ–‡å­—
  doc.fontSize(10).fillColor('#666');
  doc.text('é€£çºŒæ­£å¸¸é‹è¡Œ', startX + cardSpacing, cardY + 32, { width: cardWidth, align: 'center' });
  
  // å¡ç‰‡3ï¼šæˆåŠŸè«‹æ±‚
  doc.roundedRect(startX + cardSpacing * 2, cardY, cardWidth, cardHeight, 5)
     .fillAndStroke('#FFF3E0', '#FF9800');
  
  // ç½®ä¸­é¡¯ç¤ºæ¬¡æ•¸
  doc.fontSize(20).fillColor('#FF9800').font('NotoSansTC');
  doc.text(`${stats.successfulChecks || 0} æ¬¡`, startX + cardSpacing * 2, cardY + 10, { width: cardWidth, align: 'center' });
  
  // ç½®ä¸­é¡¯ç¤ºèªªæ˜æ–‡å­—
  doc.fontSize(10).fillColor('#666');
  doc.text('æˆåŠŸè«‹æ±‚', startX + cardSpacing * 2, cardY + 32, { width: cardWidth, align: 'center' });
}

// è¨ˆç®—æ•…éšœæ¬¡æ•¸
function calculateFailureCount(metrics) {
  if (!metrics || metrics.length === 0) return 0;
  
  return metrics.filter(m => m.status === 'down' || m.isHealthy === false).length;
}

// ç²å–æ™‚é–“ç¯„åœå°æ‡‰çš„å°æ™‚æ•¸
function getTimeRangeHours(timeRange) {
  const ranges = {
    '1h': 1,
    '6h': 6, 
    '12h': 12,
    '24h': 24,
    '1w': 168,
    '1m': 720
  };
  return ranges[timeRange] || 24;
}

// è¨ˆç®—é€£çºŒæ­£å¸¸é‹è¡Œæ™‚é–“
function calculateContinuousUptime(metrics) {
  if (!metrics || metrics.length === 0) return '24å°æ™‚';
  
  // æŸ¥æ‰¾æœ€è¿‘çš„æ•…éšœè¨˜éŒ„
  const recentMetrics = metrics.slice(-100); // å–æœ€è¿‘100å€‹è¨˜éŒ„
  const lastFailureIndex = recentMetrics.findIndex(m => m.status === 'down' || m.isHealthy === false);
  
  if (lastFailureIndex === -1) {
    return '24å°æ™‚+'; // æ²’æœ‰æ‰¾åˆ°æ•…éšœè¨˜éŒ„
  }
  
  const continuousCount = recentMetrics.length - lastFailureIndex - 1;
  const hours = Math.floor(continuousCount * 5 / 60); // å‡è¨­5åˆ†é˜é–“éš”
  const minutes = continuousCount * 5 % 60;
  
  if (hours > 0) {
    return `${hours}å°æ™‚${minutes > 0 ? minutes + 'åˆ†' : ''}`;
  } else {
    return `${minutes}åˆ†é˜`;
  }
}

// ç·Šæ¹Šç‰ˆå¯ç”¨æ€§åˆ†æåœ–è¡¨ï¼ˆä¿ç•™å‚™ç”¨ï¼‰
function drawCompactUptimeChart(doc, uptime, centerX, centerY) {
  const outerRadius = 60; // ç¸®å°åŠå¾‘
  const innerRadius = 35; // ç¸®å°å…§ç’°
  
  // è¨ˆç®—è§’åº¦
  const uptimeAngle = (uptime / 100) * Math.PI * 2;
  
  doc.save();
  doc.lineWidth(0);
  
  // ç¹ªè£½å¤–ç’°èƒŒæ™¯ï¼ˆç°è‰²ï¼‰
  doc.fillColor('#F5F5F5');
  doc.circle(centerX, centerY, outerRadius).fill();
  
  // ç¹ªè£½å…§ç’°èƒŒæ™¯ï¼ˆç™½è‰²ï¼‰
  doc.fillColor('#FFFFFF');
  doc.circle(centerX, centerY, innerRadius).fill();
  
  // ç¹ªè£½å¯ç”¨æ€§éƒ¨åˆ†
  if (uptime > 0) {
    doc.fillColor('#4CAF50');
    doc.moveTo(centerX, centerY);
    doc.lineTo(centerX + outerRadius, centerY);
    doc.arc(centerX, centerY, outerRadius, 0, uptimeAngle, false);
    doc.lineTo(centerX, centerY);
    doc.fill();
    
    // å…§åœ“æŒ–ç©º
    doc.fillColor('#FFFFFF');
    doc.circle(centerX, centerY, innerRadius).fill();
  }
  
  // ç¹ªè£½åœæ©Ÿéƒ¨åˆ†
  if (uptime < 100) {
    doc.fillColor('#F44336');
    doc.moveTo(centerX, centerY);
    doc.arc(centerX, centerY, outerRadius, uptimeAngle, Math.PI * 2, false);
    doc.lineTo(centerX, centerY);
    doc.fill();
    
    // å…§åœ“æŒ–ç©º
    doc.fillColor('#FFFFFF');
    doc.circle(centerX, centerY, innerRadius).fill();
  }
  
  // ä¸­å¤®æ•¸å€¼é¡¯ç¤º
  doc.fillColor('#333');
  doc.fontSize(24);
  doc.font('NotoSansTC');
  doc.text(`${uptime}%`, centerX - 25, centerY - 8);
  
  // æ©«å‘æŒ‡æ¨™å¡ç‰‡ï¼ˆç¯€çœå‚ç›´ç©ºé–“ï¼‰
  const cardY = centerY + 80;
  const cardWidth = 100;
  const cardHeight = 40;
  
  // å·¦å´å¡ç‰‡ - æ­£å¸¸é‹è¡Œ
  doc.roundedRect(centerX - 110, cardY, cardWidth, cardHeight, 5)
     .fillAndStroke('#E8F5E8', '#4CAF50');
  
  doc.fontSize(10).fillColor('#4CAF50').font('NotoSansTC')
     .text('æ­£å¸¸é‹è¡Œ', centerX - 100, cardY + 8);
  doc.fontSize(14)
     .text(`${uptime.toFixed(1)}%`, centerX - 100, cardY + 22);
  
  // å³å´å¡ç‰‡ - åœæ©Ÿæ™‚é–“
  const downtimePercent = (100 - uptime);
  doc.roundedRect(centerX + 10, cardY, cardWidth, cardHeight, 5)
     .fillAndStroke('#FFEBEE', '#F44336');
  
  doc.fontSize(10).fillColor('#F44336').font('NotoSansTC')
     .text('åœæ©Ÿæ™‚é–“', centerX + 20, cardY + 8);
  doc.fontSize(14)
     .text(`${downtimePercent.toFixed(1)}%`, centerX + 20, cardY + 22);
  
  doc.restore();
}

// ç¾ä»£åŒ–å¯ç”¨æ€§åˆ†æåœ–è¡¨ï¼ˆåŸç‰ˆï¼Œä¿ç•™å‚™ç”¨ï¼‰
function drawModernUptimeChart(doc, uptime, centerX, centerY) {
  const outerRadius = 80;
  const innerRadius = 50; // ç’°å½¢åœ–
  
  // è¨ˆç®—è§’åº¦
  const uptimeAngle = (uptime / 100) * Math.PI * 2;
  const downtimeAngle = Math.PI * 2 - uptimeAngle;
  
  doc.save();
  doc.lineWidth(0);
  
  // ç¹ªè£½å¤–ç’°èƒŒæ™¯ï¼ˆç°è‰²ï¼‰
  doc.fillColor('#F5F5F5');
  doc.circle(centerX, centerY, outerRadius).fill();
  
  // ç¹ªè£½å…§ç’°èƒŒæ™¯ï¼ˆç™½è‰²ï¼‰
  doc.fillColor('#FFFFFF');
  doc.circle(centerX, centerY, innerRadius).fill();
  
  // ç¹ªè£½å¯ç”¨æ€§éƒ¨åˆ†ï¼ˆæ¼¸è®Šæ•ˆæœæ¨¡æ“¬ï¼‰
  if (uptime > 0) {
    // ä¸»è‰²èª¿
    doc.fillColor('#4CAF50');
    doc.moveTo(centerX, centerY);
    doc.lineTo(centerX + outerRadius, centerY);
    doc.arc(centerX, centerY, outerRadius, 0, uptimeAngle, false);
    doc.lineTo(centerX, centerY);
    doc.fill();
    
    // å…§åœ“æŒ–ç©º
    doc.fillColor('#FFFFFF');
    doc.circle(centerX, centerY, innerRadius).fill();
  }
  
  // ç¹ªè£½åœæ©Ÿéƒ¨åˆ†
  if (uptime < 100) {
    doc.fillColor('#F44336');
    doc.moveTo(centerX, centerY);
    doc.arc(centerX, centerY, outerRadius, uptimeAngle, Math.PI * 2, false);
    doc.lineTo(centerX, centerY);
    doc.fill();
    
    // å…§åœ“æŒ–ç©º
    doc.fillColor('#FFFFFF');
    doc.circle(centerX, centerY, innerRadius).fill();
  }
  
  // ä¸­å¤®æ•¸å€¼é¡¯ç¤º - åªé¡¯ç¤ºç™¾åˆ†æ¯”ï¼Œç§»é™¤"å¯ç”¨æ€§"æ–‡å­—
  doc.fillColor('#333');
  doc.fontSize(28);
  doc.font('NotoSansTC');
  doc.text(`${uptime}%`, centerX - 30, centerY - 10);
  
  // ç¾ä»£åŒ–æŒ‡æ¨™å¡ç‰‡ - å„ªåŒ–ä½ç½®å’Œå¤§å°
  const cardY = centerY + 100;
  const cardWidth = 120;
  const cardHeight = 50;
  
  // å·¦å´å¡ç‰‡ - æ­£å¸¸é‹è¡Œ
  doc.roundedRect(centerX - 130, cardY, cardWidth, cardHeight, 6)
     .fillAndStroke('#E8F5E8', '#4CAF50');
  
  doc.fontSize(11).fillColor('#4CAF50').font('NotoSansTC')
     .text('æ­£å¸¸é‹è¡Œ', centerX - 120, cardY + 12);
  doc.fontSize(16)
     .text(`${uptime.toFixed(1)}%`, centerX - 120, cardY + 28);
  
  // å³å´å¡ç‰‡ - åœæ©Ÿæ™‚é–“
  const downtimePercent = (100 - uptime);
  doc.roundedRect(centerX + 10, cardY, cardWidth, cardHeight, 6)
     .fillAndStroke('#FFEBEE', '#F44336');
  
  doc.fontSize(11).fillColor('#F44336').font('NotoSansTC')
     .text('åœæ©Ÿæ™‚é–“', centerX + 20, cardY + 12);
  doc.fontSize(16)
     .text(`${downtimePercent.toFixed(1)}%`, centerX + 20, cardY + 28);
  
  doc.restore();
}

// èˆŠç‰ˆåœ“é¤…åœ–ï¼ˆä¿ç•™å‚™ç”¨ï¼‰
function drawUptimePieChart(doc, uptime, x, y) {
  const centerX = x + 150;
  const centerY = y + 50;
  const radius = 40;
  
  // è¨ˆç®—è§’åº¦
  const uptimeAngle = (uptime / 100) * Math.PI * 2;
  const downtimeAngle = Math.PI * 2 - uptimeAngle;
  
  // ç¹ªè£½å¯ç”¨æ€§éƒ¨åˆ†ï¼ˆç¶ è‰²ï¼‰
  doc.save();
  doc.fillColor('#4CAF50');
  doc.lineWidth(0);
  
  // ç¹ªè£½æ‰‡å½¢
  doc.moveTo(centerX, centerY);
  doc.lineTo(centerX + radius, centerY);
  doc.arc(centerX, centerY, radius, 0, uptimeAngle, false);
  doc.lineTo(centerX, centerY);
  doc.fill();
  
  // ç¹ªè£½åœæ©Ÿéƒ¨åˆ†ï¼ˆç´…è‰²ï¼‰
  if (uptime < 100) {
    doc.fillColor('#f44336');
    doc.moveTo(centerX, centerY);
    doc.arc(centerX, centerY, radius, uptimeAngle, Math.PI * 2, false);
    doc.lineTo(centerX, centerY);
    doc.fill();
  }
  
  // æ·»åŠ æ¨™ç±¤
  doc.fillColor('#333');
  doc.fontSize(14);
  doc.text(`${uptime}%`, centerX - 20, centerY - 7);
  
  // åœ–ä¾‹
  doc.fontSize(10);
  doc.fillColor('#4CAF50');
  doc.rect(x + 250, y + 30, 10, 10).fill();
  doc.fillColor('#333');
  doc.text(`å¯ç”¨ (${uptime}%)`, x + 265, y + 30);
  
  if (uptime < 100) {
    doc.fillColor('#f44336');
    doc.rect(x + 250, y + 50, 10, 10).fill();
    doc.fillColor('#333');
    doc.text(`åœæ©Ÿ (${(100 - uptime).toFixed(1)}%)`, x + 265, y + 50);
  }
  
  doc.restore();
}

// ç¶²é ç‰ˆé¢¨æ ¼çš„å †ç–Šå€åŸŸåœ–è¡¨ï¼ˆå›æ‡‰æ™‚é–“çµ„æˆåˆ†æï¼‰
function drawEnhancedResponseChart(doc, responseTimeData, startX, startY, timeRange = '24h') {
  // ç¢ºä¿ä¸æ¸²æŸ“ä»»ä½•åœ–è¡¨æ¨™é¡Œï¼ˆåŒ…æ‹¬ã€Œå›æ‡‰æ™‚é–“è¶¨å‹¢ã€ç­‰ï¼‰
  
  const chartWidth = 500;
  const chartHeight = 180; // é€²ä¸€æ­¥ç¸®å°é«˜åº¦ï¼Œæ”¾åœ¨æ™‚é–“è»¸ä¸‹æ–¹
  const margin = { top: 20, right: 30, bottom: 60, left: 60 };
  
  // æ ¹æ“šæ™‚é–“ç¯„åœç¯©é¸æ•¸æ“šï¼Œè€Œä¸æ˜¯å›ºå®šå–30å€‹é»
  let filteredData = responseTimeData;
  
  if (responseTimeData.length > 0) {
    const now = new Date();
    const timeRangeMs = getTimeRangeInMs(timeRange);
    const cutoffTime = new Date(now.getTime() - timeRangeMs);
    
    // ç¯©é¸åœ¨æ™‚é–“ç¯„åœå…§çš„æ•¸æ“š
    filteredData = responseTimeData.filter(point => {
      const pointTime = new Date(point.timestamp || point.time);
      return pointTime >= cutoffTime;
    });
    
    // å¦‚æœæ•¸æ“šå¤ªå¤šï¼Œå–æ¨£æœ¬ä»¥æé«˜æ€§èƒ½ï¼ˆæœ€å¤š100å€‹é»ï¼‰
    if (filteredData.length > 100) {
      const step = Math.ceil(filteredData.length / 100);
      filteredData = filteredData.filter((_, index) => index % step === 0);
    }
  }
  
  const recentData = filteredData;
  if (recentData.length === 0) return;
  
  // è¨ˆç®—ç¸½å›æ‡‰æ™‚é–“ç¯„åœï¼ˆåŒ…å«æ‰€æœ‰çµ„æˆéƒ¨åˆ†ï¼‰
  let maxTotalTime = 0;
  recentData.forEach(point => {
    const totalTime = (point.dnsTime || 0) + (point.connectTime || 0) + 
                     (point.sslHandshakeTime || 0) + (point.timeToFirstByte || 0) + 
                     (point.downloadTime || point.responseTime || 0);
    maxTotalTime = Math.max(maxTotalTime, totalTime);
  });
  
  // å¦‚æœæ²’æœ‰åˆ†è§£æ•¸æ“šï¼Œä½¿ç”¨responseTimeä½œç‚ºç¸½æ™‚é–“
  if (maxTotalTime === 0) {
    maxTotalTime = Math.max(...recentData.map(d => d.responseTime || 0));
  }
  
  const responseRange = maxTotalTime + 50;
  
  // ç¹ªè£½åœ–è¡¨èƒŒæ™¯ - ä½¿ç”¨æ¼¸å±¤æ•ˆæœ
  doc.rect(startX, startY, chartWidth, chartHeight)
     .fillColor('#ffffff')
     .fill()
     .strokeColor('#e0e0e0')
     .lineWidth(1)
     .stroke();
  
  // ç¹ªè£½åœ–è¡¨å…§éƒ¨èƒŒæ™¯
  const plotArea = {
    x: startX + margin.left,
    y: startY + margin.top,
    width: chartWidth - margin.left - margin.right,
    height: chartHeight - margin.top - margin.bottom
  };
  
  doc.rect(plotArea.x, plotArea.y, plotArea.width, plotArea.height)
     .fillColor('#fafbfc')
     .fill();
  
  // ç¹ªè£½ç²¾ç´°ç¶²æ ¼ç·š
  const gridLines = 6;
  doc.strokeColor('#f0f0f0').lineWidth(0.5);
  
  // æ°´å¹³ç¶²æ ¼ç·š
  for (let i = 0; i <= gridLines; i++) {
    const y = plotArea.y + plotArea.height * i / gridLines;
    doc.moveTo(plotArea.x, y)
       .lineTo(plotArea.x + plotArea.width, y)
       .stroke();
  }
  
  // å‚ç›´ç¶²æ ¼ç·š
  const verticalLines = Math.min(recentData.length, 10);
  for (let i = 0; i <= verticalLines; i++) {
    const x = plotArea.x + plotArea.width * i / verticalLines;
    doc.moveTo(x, plotArea.y)
       .lineTo(x, plotArea.y + plotArea.height)
       .stroke();
  }
  
  // Yè»¸æ¨™ç±¤å’Œåˆ»åº¦
  doc.fillColor('#666666').fontSize(9);
  for (let i = 0; i <= gridLines; i++) {
    const value = maxTotalTime - (responseRange * i / gridLines);
    const y = plotArea.y + plotArea.height * i / gridLines;
    
    // åˆ»åº¦ç·š
    doc.strokeColor('#cccccc').lineWidth(1);
    doc.moveTo(startX + margin.left - 5, y)
       .lineTo(startX + margin.left, y)
       .stroke();
    
    // æ¨™ç±¤ - ä½¿ç”¨æ™ºèƒ½æ ¼å¼åŒ–
    doc.text(formatResponseTime(Math.round(value)), startX + 10, y - 6, { 
      align: 'right',
      width: margin.left - 15
    });
  }
  
  // Yè»¸æ¨™é¡Œ
  doc.fillColor('#333333').fontSize(10);
  doc.save();
  doc.translate(startX + 15, startY + chartHeight / 2);
  doc.rotate(-90);
  // ç§»é™¤ Y è»¸æ¨™ç±¤ã€Œå›æ‡‰æ™‚é–“ (ms)ã€
  doc.restore();
  
  // å®šç¾©å †ç–Šå€åŸŸçš„é¡è‰²ï¼ˆå°æ‡‰ç¶²é ç‰ˆï¼‰
  const stackColors = {
    dns: '#16a34a',        // ç¶ è‰² - DNSæŸ¥è©¢æ™‚é–“
    connect: '#f59e0b',    // é»ƒè‰² - é€£æ¥å»ºç«‹æ™‚é–“  
    ssl: '#8b5cf6',        // ç´«è‰² - SSLäº¤æ¡æ™‚é–“
    ttfb: '#ef4444',       // ç´…è‰² - ç­‰å¾…æ™‚é–“(TTFB)
    download: '#06b6d4'    // é’è‰² - å…§å®¹ä¸‹è¼‰æ™‚é–“
  };
  
  // ç¹ªè£½å †ç–Šå€åŸŸåœ–
  if (recentData.length > 1) {
    
    // å®šç¾©å †ç–Šé †åºï¼ˆå¾ä¸‹åˆ°ä¸Šï¼‰
    const stackLayers = [
      { key: 'dnsTime', color: stackColors.dns, name: 'DNSæŸ¥è©¢' },
      { key: 'connectTime', color: stackColors.connect, name: 'é€£æ¥å»ºç«‹' },
      { key: 'sslHandshakeTime', color: stackColors.ssl, name: 'SSLäº¤æ¡' },
      { key: 'timeToFirstByte', color: stackColors.ttfb, name: 'ç­‰å¾…æ™‚é–“' },
      { key: 'downloadTime', color: stackColors.download, name: 'ä¸‹è¼‰å…§å®¹' }
    ];
    
    // ç‚ºæ¯å€‹æ•¸æ“šé»è¨ˆç®—ç´¯ç©å€¼
    const processedData = recentData.map((point, index) => {
      let cumulativeValue = 0;
      const layers = {};
      
      // å¦‚æœæ²’æœ‰åˆ†è§£æ•¸æ“šï¼Œå°‡æ•´å€‹responseTimeä½œç‚ºdownloadæ™‚é–“
      if (!point.dnsTime && !point.connectTime && !point.sslHandshakeTime && 
          !point.timeToFirstByte && !point.downloadTime) {
        layers.downloadTime = point.responseTime || 0;
        cumulativeValue = point.responseTime || 0;
      } else {
        // ä½¿ç”¨åˆ†è§£çš„æ™‚é–“æ•¸æ“š
        stackLayers.forEach(layer => {
          const value = point[layer.key] || 0;
          layers[layer.key] = cumulativeValue;
          cumulativeValue += value;
        });
      }
      
      const x = plotArea.x + (plotArea.width * index / (recentData.length - 1));
      return { ...layers, x, totalHeight: cumulativeValue };
    });
    
    // ç¹ªè£½æ¯å€‹å †ç–Šå±¤
    stackLayers.forEach(layer => {
      doc.fillColor(layer.color);
      
      // å‰µå»ºè©²å±¤çš„è·¯å¾‘
      let hasData = false;
      const pathPoints = [];
      
      processedData.forEach(dataPoint => {
        const layerBottom = dataPoint[layer.key] || 0;
        const layerTop = layerBottom + (recentData[processedData.indexOf(dataPoint)][layer.key] || 0);
        
        if (layerTop > layerBottom) {
          hasData = true;
          
          const yBottom = plotArea.y + plotArea.height * (1 - layerBottom / responseRange);
          const yTop = plotArea.y + plotArea.height * (1 - layerTop / responseRange);
          
          pathPoints.push({
            x: dataPoint.x,
            yBottom: Math.max(plotArea.y, Math.min(plotArea.y + plotArea.height, yBottom)),
            yTop: Math.max(plotArea.y, Math.min(plotArea.y + plotArea.height, yTop))
          });
        }
      });
      
      // ç¹ªè£½è©²å±¤çš„å¡«å……å€åŸŸ
      if (hasData && pathPoints.length > 0) {
        // ä¸Šé‚Šç•Œ
        doc.moveTo(pathPoints[0].x, pathPoints[0].yTop);
        pathPoints.forEach(point => {
          doc.lineTo(point.x, point.yTop);
        });
        
        // å³é‚Šç•Œåˆ°ä¸‹é‚Šç•Œ
        for (let i = pathPoints.length - 1; i >= 0; i--) {
          doc.lineTo(pathPoints[i].x, pathPoints[i].yBottom);
        }
        
        // é–‰åˆè·¯å¾‘ä¸¦å¡«å……
        doc.closePath();
        doc.fill();
      }
    });
    
    // ç¹ªè£½é‚Šæ¡†ç·š
    doc.strokeColor('#cccccc').lineWidth(0.5);
    processedData.forEach(dataPoint => {
      const totalY = plotArea.y + plotArea.height * (1 - dataPoint.totalHeight / responseRange);
      if (dataPoint === processedData[0]) {
        doc.moveTo(dataPoint.x, totalY);
      } else {
        doc.lineTo(dataPoint.x, totalY);
      }
    });
    doc.stroke();
  }
  
  // Xè»¸æ™‚é–“æ¨™ç±¤ - é¡¯ç¤ºå¤šå€‹æ™‚é–“é»
  if (recentData.length > 0) {
    doc.fillColor('#666666').fontSize(9);
    
    const timePoints = Math.min(5, recentData.length);
    for (let i = 0; i < timePoints; i++) {
      const dataIndex = Math.floor(recentData.length * i / (timePoints - 1));
      const point = recentData[Math.min(dataIndex, recentData.length - 1)];
      const x = plotArea.x + (plotArea.width * i / (timePoints - 1));
      
      // è™•ç†æ™‚é–“æˆ³æ ¼å¼ - ä¿®æ­£æ™‚é–“æ¨™ç±¤é¡¯ç¤º
      let timeStr = '';
      
      // å˜—è©¦å¤šç¨®æ™‚é–“å­—æ®µåç¨±
      const timeValue = point.timestamp || point.time || point.date;
      
      if (timeValue) {
        try {
          let date;
          
          // å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œå˜—è©¦ç›´æ¥è§£æ
          if (typeof timeValue === 'string') {
            date = new Date(timeValue);
          } else if (typeof timeValue === 'number') {
            // å¦‚æœæ˜¯æ•¸å­—ï¼Œåˆ¤æ–·æ˜¯ç§’é‚„æ˜¯æ¯«ç§’
            date = timeValue < 10000000000 ? new Date(timeValue * 1000) : new Date(timeValue);
          } else {
            date = new Date(timeValue);
          }
          
          // é©—è­‰æ—¥æœŸæ˜¯å¦æœ‰æ•ˆ
          if (!isNaN(date.getTime()) && date.getTime() > 0) {
            // è½‰æ›ç‚ºå°ç£æ™‚å€
            const taiwanTime = moment(date).utc().utcOffset(8);
            timeStr = taiwanTime.format('HH:mm');
          } else {
            console.log('Invalid date:', timeValue, 'for point:', point);
            // ä½¿ç”¨ç›¸å°æ™‚é–“æ¨™ç±¤
            const startTime = moment().subtract(getTimeRangeInMs(timeRange), 'milliseconds');
            const relativeTime = startTime.clone().add(i * (getTimeRangeInMs(timeRange) / (timePoints - 1)), 'milliseconds');
            timeStr = relativeTime.format('HH:mm');
          }
        } catch (error) {
          console.log('Time parsing error:', error, 'for value:', timeValue);
          // ä½¿ç”¨ç›¸å°æ™‚é–“æ¨™ç±¤
          const startTime = moment().subtract(getTimeRangeInMs(timeRange), 'milliseconds');
          const relativeTime = startTime.clone().add(i * (getTimeRangeInMs(timeRange) / (timePoints - 1)), 'milliseconds');
          timeStr = relativeTime.format('HH:mm');
        }
      } else {
        console.log('No time field found in point:', point);
        // ä½¿ç”¨ç›¸å°æ™‚é–“æ¨™ç±¤
        const startTime = moment().subtract(getTimeRangeInMs(timeRange), 'milliseconds');
        const relativeTime = startTime.clone().add(i * (getTimeRangeInMs(timeRange) / (timePoints - 1)), 'milliseconds');
        timeStr = relativeTime.format('HH:mm');
      }
      
      // åˆ»åº¦ç·š
      doc.strokeColor('#cccccc').lineWidth(1);
      doc.moveTo(x, plotArea.y + plotArea.height)
         .lineTo(x, plotArea.y + plotArea.height + 8)
         .stroke();
      
      // æ™‚é–“æ¨™ç±¤ - å‘ä¸‹ç§»å‹•é¿å…èˆ‡åœ–è¡¨é‡ç–Š
      doc.text(timeStr, x - 20, plotArea.y + plotArea.height + 18, { 
        align: 'center',
        width: 40
      });
    }
  }
  
  // Xè»¸æ¨™é¡Œå·²ç§»é™¤ï¼Œä¸é¡¯ç¤º"æª¢æŸ¥æ™‚é–“"æ–‡å­—
  
  // åœ–è¡¨é‚Šæ¡†
  doc.rect(plotArea.x, plotArea.y, plotArea.width, plotArea.height)
     .strokeColor('#cccccc')
     .lineWidth(1)
     .stroke();

  // ç¹ªè£½åœ–ä¾‹ï¼ˆå †ç–Šå€åŸŸèªªæ˜ï¼‰- èª¿æ•´ä½ç½®é¿å…èˆ‡æ™‚é–“æ¨™ç±¤é‡ç–Š
  let legendY = startY + chartHeight - 15; // é€²ä¸€æ­¥å‘ä¸‹èª¿æ•´é¿å…é‡ç–Š
  const legendItemWidth = 90;
  let legendX = startX + margin.left;
  
  doc.fontSize(8).fillColor('#666666');
  
  const stackLegends = [
    { color: stackColors.dns, name: 'DNSæŸ¥è©¢' },
    { color: stackColors.connect, name: 'é€£æ¥å»ºç«‹' },
    { color: stackColors.ssl, name: 'SSLäº¤æ¡' },
    { color: stackColors.ttfb, name: 'ç­‰å¾…æ™‚é–“' },
    { color: stackColors.download, name: 'ä¸‹è¼‰å…§å®¹' }
  ];
  
  stackLegends.forEach((legend, index) => {
    // ç§»é™¤æ›è¡Œé‚è¼¯ï¼Œè®“æ‰€æœ‰åœ–ä¾‹é …ç›®ä¿æŒåœ¨åŒä¸€è¡Œ
    
    // è‰²å¡Š
    doc.rect(legendX, legendY, 8, 8)
       .fillColor(legend.color)
       .fill();
    
    // æ–‡å­—
    doc.fillColor('#666666')
       .text(legend.name, legendX + 12, legendY + 1);
    
    legendX += legendItemWidth;
  });
}

// ç¹ªè£½å›æ‡‰æ™‚é–“æŠ˜ç·šåœ–ï¼ˆèˆŠç‰ˆï¼Œä¿ç•™å‚™ç”¨ï¼‰
function drawResponseTimeChart(doc, metrics, x, y, width, height) {
  // æº–å‚™æ•¸æ“šï¼ˆæœ€å¤šé¡¯ç¤º30å€‹æ•¸æ“šé»ï¼‰
  const displayData = metrics.slice(-30);
  if (displayData.length === 0) return;
  
  // æ‰¾å‡ºæœ€å¤§æœ€å°å€¼
  const maxTime = Math.max(...displayData.map(d => d.responseTime));
  const minTime = Math.min(...displayData.map(d => d.responseTime));
  const range = maxTime - minTime || 1;
  
  // ç¹ªè£½åº§æ¨™è»¸
  doc.save();
  doc.strokeColor('#666');
  doc.lineWidth(1);
  
  // Yè»¸
  doc.moveTo(x, y).lineTo(x, y + height).stroke();
  
  // Xè»¸
  doc.moveTo(x, y + height).lineTo(x + width, y + height).stroke();
  
  // Yè»¸æ¨™ç±¤
  doc.fontSize(9);
  doc.fillColor('#666');
  doc.text(`${maxTime}ms`, x - 40, y - 5);
  doc.text(`${Math.round((maxTime + minTime) / 2)}ms`, x - 40, y + height/2 - 5);
  doc.text(`${minTime}ms`, x - 40, y + height - 5);
  
  // ç¹ªè£½ç¶²æ ¼ç·š
  doc.strokeColor('#e0e0e0');
  doc.lineWidth(0.5);
  for (let i = 1; i < 5; i++) {
    const yPos = y + (height * i / 5);
    doc.moveTo(x, yPos).lineTo(x + width, yPos).stroke();
  }
  
  // ç¹ªè£½æ•¸æ“šç·š
  doc.strokeColor('#1976D2');
  doc.lineWidth(2);
  
  const xStep = width / (displayData.length - 1 || 1);
  
  displayData.forEach((data, index) => {
    const xPos = x + (index * xStep);
    const yPos = y + height - ((data.responseTime - minTime) / range * height);
    
    if (index === 0) {
      doc.moveTo(xPos, yPos);
    } else {
      doc.lineTo(xPos, yPos);
    }
  });
  doc.stroke();
  
  // ç¹ªè£½æ•¸æ“šé»
  doc.fillColor('#1976D2');
  displayData.forEach((data, index) => {
    const xPos = x + (index * xStep);
    const yPos = y + height - ((data.responseTime - minTime) / range * height);
    doc.circle(xPos, yPos, 2).fill();
  });
  
  // Xè»¸æ™‚é–“æ¨™ç±¤ï¼ˆé¡¯ç¤ºé¦–å°¾æ™‚é–“ï¼‰
  doc.fontSize(8);
  doc.fillColor('#666');
  if (displayData.length > 0) {
    const firstTime = moment(displayData[0].time).utc().utcOffset(8).format('HH:mm');
    const lastTime = moment(displayData[displayData.length - 1].time).utc().utcOffset(8).format('HH:mm');
    doc.text(firstTime, x - 10, y + height + 10);
    doc.text(lastTime, x + width - 20, y + height + 10);
  }
  
  // æ¨™é¡Œ
  doc.fontSize(10);
  doc.fillColor('#333');
  doc.text(`æœ€è¿‘ ${displayData.length} æ¬¡æª¢æŸ¥`, x + width/2 - 40, y + height + 25);
  
  doc.restore();
}

module.exports = router;